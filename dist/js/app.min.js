/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.guid = guid;
exports.randomHex = randomHex;
exports.getDistance = getDistance;
exports.isNull = isNull;
exports.coordsAreNull = coordsAreNull;
function guid() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    // return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    return "" + s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
}

function randomHex() {
    return '#' + Math.floor(Math.random() * 16777215).toString(16);
}

function getDistance(coords1, coords2) {
    return Math.sqrt(Math.pow(coords1.x - coords2.x, 2) + Math.pow(coords1.y - coords2.y, 2));
}

function isNull(value) {
    return value === null;
}

function coordsAreNull(obj) {
    return isNull(obj.x) && isNull(obj.y);
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals console */

// import './rAF-polyfill.js';

var _state = __webpack_require__(2);

var _state2 = _interopRequireDefault(_state);

var _canvasSetup = __webpack_require__(3);

var _canvasSetup2 = _interopRequireDefault(_canvasSetup);

var _addUser = __webpack_require__(7);

var _addUser2 = _interopRequireDefault(_addUser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// let renderer;
var app = {
    state: _state2.default

    // draw() {
    // let time;
    // let controls = document.getElementById('controls');
    // time = new Date();
    // controls.innerText = `${time.getHours()}:${time.getMinutes()}:${time.getSeconds()}.${time.getMilliseconds()}`;

    // // this.renderer.clear();
    // if (this.state.nodes.length) {
    //     this.state.nodes.forEach(node => {
    //         // check if node.userID matches userID
    //         // if so, use coords for circle; get node color from state.user[userID].color
    //     })
    // }
    // },
};

Promise.resolve(app).then(_addUser2.default).then(_canvasSetup2.default)
// .then(() => animate())
.then(function () {
    return console.log("state", _state2.default);
}).catch(function (thrown) {
    return console.error('%cAn error occurred:', 'font-weight:bold', thrown);
});

// function animate() {
//     app.draw();
//     requestAnimationFrame(animate);
// }
function output(str) {
    document.getElementById('output').innerHTML += '<br>' + str;
}
window.getState = function () {
    return console.log('app.state', app.state);
};
/*
TODO: get touch-add working
-- create node using user's color
-- save node info to nodes array
TODO: share state over websockets
TODO: update state object when socket info comes in
 */

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// The Truth!

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    nodes: [],
    connections: [],
    users: {},
    currentUser: {
        userID: '',
        color: ''
    }
};

/*
e.g. 
{
    nodes: [{
        userID: 'guid',
        coords: [{ x:0, y:0 }],
        nodeID: 'guid'
    }],
    connections: [{
        e1: { x:0, y:0 },
        e2: { x:0, y:0 },
    }],
    users: {
        guid: {
            color: ''
        }
    }
}
 */

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*  */

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = canvasSetup;

var _spawnNode = __webpack_require__(4);

var _spawnNode2 = _interopRequireDefault(_spawnNode);

var _findNearestNodes = __webpack_require__(5);

var _findNearestNodes2 = _interopRequireDefault(_findNearestNodes);

var _drawLine = __webpack_require__(6);

var _drawLine2 = _interopRequireDefault(_drawLine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var canvas = void 0;function canvasSetup(app) {
    var nearestNodes = new _findNearestNodes2.default(app);
    canvas = new fabric.Canvas('stage');

    fabric.Group.prototype.hasControls = false;
    canvas.selection = false;

    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas();
    app.resizeCanvas = resizeCanvas;
    app.canvas = canvas;

    canvas.on({
        'mouse:down': function mouseDown(event) {
            var node = (0, _spawnNode2.default)(app, event);
            if (node) {
                var nodes = nearestNodes.findClosestTo(node);
                console.log("nodes", nodes);
                console.log('closest', nodes.closest, 'nextClosest', nodes.nextClosest);
                // draw lines
                // draw line from node.xy to closest.xy
                // draw line from node.xy to nextClosest.xy
                // save drawn lines to connections in state

                (0, _drawLine2.default)(app, event, node, nodes.closest);
                (0, _drawLine2.default)(app, event, node, nodes.nextClosest);
            }
        }
    });

    return app;
}

function resizeCanvas() {
    canvas.setHeight(window.innerHeight);
    canvas.setWidth(window.innerWidth);
    canvas.renderAll();
}
// export default function canvasSetup(app) {
//     let canvas = document.getElementById('stage');
//     app.renderer = new Renderer(canvas);

//     return app;
// }

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = spawnNode;

var _utils = __webpack_require__(0);

var nodeRadius = 50;

function spawnNode(app, event) {
    var _ref = event.e.touches ? event.e.touches[0] : event.e,
        pageX = _ref.pageX,
        pageY = _ref.pageY;

    if (!event.target) {
        var offset = -20;
        var nodeID = (0, _utils.guid)();
        var centered = {
            x: pageX - nodeRadius,
            y: pageY - nodeRadius
        };
        addCircle({
            x: centered.x,
            y: centered.y,
            color: app.state.currentUser.color,
            canvas: app.canvas,
            nodeID: nodeID
        });
        var currentUser = app.state.currentUser;
        app.state.nodes.push({
            color: currentUser.color,
            coords: centered,
            userID: currentUser.userID,
            nodeID: nodeID
        });
        return {
            x: centered.x,
            y: centered.y,
            nodeID: nodeID
        };
    }
}

function addCircle(_ref2) {
    var x = _ref2.x,
        y = _ref2.y,
        color = _ref2.color,
        canvas = _ref2.canvas,
        nodeID = _ref2.nodeID;

    // console.log("x, y, color, canvas", x, y, color, canvas);
    var circle = new fabric.Circle({
        left: x,
        top: y,
        radius: nodeRadius,
        fill: color,
        hasControls: false,
        id: nodeID
    });
    canvas.add(circle);
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals Math */

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var emptyCoords = function emptyCoords() {
    return { x: null, y: null, nodeID: '' };
};
var closest = emptyCoords();
var nextClosest = emptyCoords();

var NearestNodes = function () {
    function NearestNodes(app) {
        _classCallCheck(this, NearestNodes);

        // this.app = app;
        this.nodes = app.state.nodes;
    }

    // only using getter/setter pattern in case I pass object to set coords and it has more than x/y


    _createClass(NearestNodes, [{
        key: 'findClosestTo',
        value: function findClosestTo(_ref) {
            var _this = this;

            var x = _ref.x,
                y = _ref.y,
                nodeID = _ref.nodeID;

            var coords = { x: x, y: y };
            this.nodes.forEach(function (tmpNode) {
                if (nodeID === tmpNode.nodeID) return;

                if ((0, _utils.coordsAreNull)(_this.closest)) {
                    _this.closest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                } else if (distance(coords, _this.closest) > distance(coords, tmpNode.coords)) {
                    _this.nextClosest = _this.closest;
                    _this.closest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                } else if ((0, _utils.coordsAreNull)(_this.nextClosest) || distance(coords, _this.nextClosest) > distance(coords, tmpNode.coords)) {

                    _this.nextClosest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                }
            });
            return {
                closest: this.closest,
                nextClosest: this.nextClosest
            };
        }
    }, {
        key: 'closest',
        get: function get() {
            return closest;
        },
        set: function set(_ref2) {
            var x = _ref2.x,
                y = _ref2.y,
                nodeID = _ref2.nodeID;

            closest.x = x;
            closest.y = y;
            closest.nodeID = nodeID;
        }
    }, {
        key: 'nextClosest',
        get: function get() {
            return nextClosest;
        },
        set: function set(_ref3) {
            var x = _ref3.x,
                y = _ref3.y,
                nodeID = _ref3.nodeID;

            nextClosest.x = x;
            nextClosest.y = y;
            nextClosest.nodeID = nodeID;
        }
    }]);

    return NearestNodes;
}();

exports.default = NearestNodes;


function distance(_ref4, _ref5) {
    var x1 = _ref4.x,
        y1 = _ref4.y;
    var x2 = _ref5.x,
        y2 = _ref5.y;

    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals console */

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = drawLine;

var _utils = __webpack_require__(0);

// Things needed to draw lines
// - color
// - start point (coords & parent circle ID)
// - end point (coords & parent circle ID)
function drawLine(app, event, startNode, endNode) {
    // TODO remove event param?
    if ((0, _utils.coordsAreNull)(endNode)) return;

    console.log("startNode", startNode);
    console.log("endNode", endNode);
    var lineColor = '#000000';
    var coords = [startNode.x, startNode.y, endNode.x, endNode.y];
    console.log("coords", coords);

    addLine(coords, lineColor, app.canvas);
}

function addLine(coords, color, canvas) {
    var line = new fabric.Line(coords, {
        stroke: color,
        strokeWidth: 5,
        selectable: false
    });
    console.log("line", line);

    canvas.add(line);
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addUser;

var _utils = __webpack_require__(0);

function addUser(app) {
    var userID = (0, _utils.guid)();
    var color = (0, _utils.randomHex)();
    app.state.users[userID] = { color: color };

    app.state.currentUser = {
        userID: userID, color: color
    };

    return app;
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYmRhYjExMTU2ZDRiN2MyZGQ4NDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NsaWVudC9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NsaWVudC9zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jbGllbnQvY2FudmFzLXNldHVwLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NsaWVudC9zcGF3bi1ub2RlLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NsaWVudC9maW5kLW5lYXJlc3Qtbm9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L2RyYXctbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jbGllbnQvYWRkLXVzZXIuanMiXSwibmFtZXMiOlsiZ3VpZCIsInJhbmRvbUhleCIsImdldERpc3RhbmNlIiwiaXNOdWxsIiwiY29vcmRzQXJlTnVsbCIsInM0IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJjb29yZHMxIiwiY29vcmRzMiIsInNxcnQiLCJwb3ciLCJ4IiwieSIsInZhbHVlIiwib2JqIiwiYXBwIiwic3RhdGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJjb25zb2xlIiwibG9nIiwiY2F0Y2giLCJlcnJvciIsInRocm93biIsIm91dHB1dCIsInN0ciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJpbm5lckhUTUwiLCJ3aW5kb3ciLCJnZXRTdGF0ZSIsIm5vZGVzIiwiY29ubmVjdGlvbnMiLCJ1c2VycyIsImN1cnJlbnRVc2VyIiwidXNlcklEIiwiY29sb3IiLCJjYW52YXNTZXR1cCIsImNhbnZhcyIsIm5lYXJlc3ROb2RlcyIsImZhYnJpYyIsIkNhbnZhcyIsIkdyb3VwIiwicHJvdG90eXBlIiwiaGFzQ29udHJvbHMiLCJzZWxlY3Rpb24iLCJhZGRFdmVudExpc3RlbmVyIiwicmVzaXplQ2FudmFzIiwib24iLCJub2RlIiwiZXZlbnQiLCJmaW5kQ2xvc2VzdFRvIiwiY2xvc2VzdCIsIm5leHRDbG9zZXN0Iiwic2V0SGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJzZXRXaWR0aCIsImlubmVyV2lkdGgiLCJyZW5kZXJBbGwiLCJzcGF3bk5vZGUiLCJub2RlUmFkaXVzIiwiZSIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwidGFyZ2V0Iiwib2Zmc2V0Iiwibm9kZUlEIiwiY2VudGVyZWQiLCJhZGRDaXJjbGUiLCJwdXNoIiwiY29vcmRzIiwiY2lyY2xlIiwiQ2lyY2xlIiwibGVmdCIsInRvcCIsInJhZGl1cyIsImZpbGwiLCJpZCIsImFkZCIsImVtcHR5Q29vcmRzIiwiTmVhcmVzdE5vZGVzIiwiZm9yRWFjaCIsInRtcE5vZGUiLCJPYmplY3QiLCJhc3NpZ24iLCJkaXN0YW5jZSIsIngxIiwieTEiLCJ4MiIsInkyIiwiZHJhd0xpbmUiLCJzdGFydE5vZGUiLCJlbmROb2RlIiwibGluZUNvbG9yIiwiYWRkTGluZSIsImxpbmUiLCJMaW5lIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzZWxlY3RhYmxlIiwiYWRkVXNlciJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzdEQTs7Ozs7UUFFZ0JBLEksR0FBQUEsSTtRQVVBQyxTLEdBQUFBLFM7UUFJQUMsVyxHQUFBQSxXO1FBSUFDLE0sR0FBQUEsTTtRQUlBQyxhLEdBQUFBLGE7QUF0QlQsU0FBU0osSUFBVCxHQUFnQjtBQUNuQixhQUFTSyxFQUFULEdBQWM7QUFDVixlQUFPQyxLQUFLQyxLQUFMLENBQVcsQ0FBQyxJQUFJRCxLQUFLRSxNQUFMLEVBQUwsSUFBc0IsT0FBakMsRUFDRkMsUUFERSxDQUNPLEVBRFAsRUFFRkMsU0FGRSxDQUVRLENBRlIsQ0FBUDtBQUdIO0FBQ0Q7QUFDQSxnQkFBVUwsSUFBVixHQUFpQkEsSUFBakIsU0FBeUJBLElBQXpCLFNBQWlDQSxJQUFqQyxTQUF5Q0EsSUFBekMsU0FBaURBLElBQWpELEdBQXdEQSxJQUF4RCxHQUErREEsSUFBL0Q7QUFDSDs7QUFFTSxTQUFTSixTQUFULEdBQXFCO0FBQ3hCLFdBQU8sTUFBTUssS0FBS0MsS0FBTCxDQUFXRCxLQUFLRSxNQUFMLEtBQWMsUUFBekIsRUFBbUNDLFFBQW5DLENBQTRDLEVBQTVDLENBQWI7QUFDSDs7QUFFTSxTQUFTUCxXQUFULENBQXFCUyxPQUFyQixFQUE4QkMsT0FBOUIsRUFBdUM7QUFDMUMsV0FBT04sS0FBS08sSUFBTCxDQUFVUCxLQUFLUSxHQUFMLENBQVVILFFBQVFJLENBQVIsR0FBWUgsUUFBUUcsQ0FBOUIsRUFBa0MsQ0FBbEMsSUFBdUNULEtBQUtRLEdBQUwsQ0FBVUgsUUFBUUssQ0FBUixHQUFZSixRQUFRSSxDQUE5QixFQUFrQyxDQUFsQyxDQUFqRCxDQUFQO0FBQ0g7O0FBRU0sU0FBU2IsTUFBVCxDQUFnQmMsS0FBaEIsRUFBdUI7QUFDMUIsV0FBT0EsVUFBVSxJQUFqQjtBQUNIOztBQUVNLFNBQVNiLGFBQVQsQ0FBdUJjLEdBQXZCLEVBQTRCO0FBQy9CLFdBQU9mLE9BQU9lLElBQUlILENBQVgsS0FBaUJaLE9BQU9lLElBQUlGLENBQVgsQ0FBeEI7QUFDSCxDOzs7Ozs7O0FDMUJEO0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTtBQUNBLElBQUlHLE1BQU07QUFDTkM7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNKO0FBaEJNLENBQVY7O0FBbUJBQyxRQUFRQyxPQUFSLENBQWdCSCxHQUFoQixFQUNLSSxJQURMLG9CQUVLQSxJQUZMO0FBR0k7QUFISixDQUlLQSxJQUpMLENBSVU7QUFBQSxXQUFNQyxRQUFRQyxHQUFSLENBQVksT0FBWixrQkFBTjtBQUFBLENBSlYsRUFLS0MsS0FMTCxDQUtXO0FBQUEsV0FBVUYsUUFBUUcsS0FBUixDQUFjLHNCQUFkLEVBQXNDLGtCQUF0QyxFQUEwREMsTUFBMUQsQ0FBVjtBQUFBLENBTFg7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxNQUFULENBQWdCQyxHQUFoQixFQUFxQjtBQUNqQkMsYUFBU0MsY0FBVCxDQUF3QixRQUF4QixFQUFrQ0MsU0FBbEMsYUFBc0RILEdBQXREO0FBQ0g7QUFDREksT0FBT0MsUUFBUCxHQUFrQjtBQUFBLFdBQU1YLFFBQVFDLEdBQVIsQ0FBWSxXQUFaLEVBQXlCTixJQUFJQyxLQUE3QixDQUFOO0FBQUEsQ0FBbEI7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVDQTs7QUFFQTs7Ozs7a0JBQ2U7QUFDWGdCLFdBQU8sRUFESTtBQUVYQyxpQkFBYSxFQUZGO0FBR1hDLFdBQU8sRUFISTtBQUlYQyxpQkFBYTtBQUNUQyxnQkFBUSxFQURDO0FBRVRDLGVBQU87QUFGRTtBQUpGLEM7O0FBVWY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBOzs7OztrQkFPd0JDLFc7O0FBTnhCOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBSUMsZUFBSixDQUVlLFNBQVNELFdBQVQsQ0FBcUJ2QixHQUFyQixFQUEwQjtBQUNyQyxRQUFNeUIsZUFBZSwrQkFBaUJ6QixHQUFqQixDQUFyQjtBQUNBd0IsYUFBUyxJQUFJRSxPQUFPQyxNQUFYLENBQWtCLE9BQWxCLENBQVQ7O0FBRUFELFdBQU9FLEtBQVAsQ0FBYUMsU0FBYixDQUF1QkMsV0FBdkIsR0FBcUMsS0FBckM7QUFDQU4sV0FBT08sU0FBUCxHQUFtQixLQUFuQjs7QUFFQWhCLFdBQU9pQixnQkFBUCxDQUF3QixRQUF4QixFQUFrQ0MsWUFBbEMsRUFBZ0QsS0FBaEQ7QUFDQUE7QUFDQWpDLFFBQUlpQyxZQUFKLEdBQW1CQSxZQUFuQjtBQUNBakMsUUFBSXdCLE1BQUosR0FBYUEsTUFBYjs7QUFFQUEsV0FBT1UsRUFBUCxDQUFVO0FBQ04sc0JBQWMsMEJBQVM7QUFDbkIsZ0JBQUlDLE9BQU8seUJBQVVuQyxHQUFWLEVBQWVvQyxLQUFmLENBQVg7QUFDQSxnQkFBSUQsSUFBSixFQUFVO0FBQ04sb0JBQUlsQixRQUFRUSxhQUFhWSxhQUFiLENBQTJCRixJQUEzQixDQUFaO0FBQ0E5Qix3QkFBUUMsR0FBUixDQUFZLE9BQVosRUFBcUJXLEtBQXJCO0FBQ0FaLHdCQUFRQyxHQUFSLENBQ0ksU0FESixFQUNlVyxNQUFNcUIsT0FEckIsRUFFSSxhQUZKLEVBRW1CckIsTUFBTXNCLFdBRnpCO0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQVN2QyxHQUFULEVBQWNvQyxLQUFkLEVBQXFCRCxJQUFyQixFQUEyQmxCLE1BQU1xQixPQUFqQztBQUNBLHdDQUFTdEMsR0FBVCxFQUFjb0MsS0FBZCxFQUFxQkQsSUFBckIsRUFBMkJsQixNQUFNc0IsV0FBakM7QUFDSDtBQUNKO0FBbEJLLEtBQVY7O0FBcUJBLFdBQU92QyxHQUFQO0FBQ0g7O0FBRUQsU0FBU2lDLFlBQVQsR0FBd0I7QUFDcEJULFdBQU9nQixTQUFQLENBQWlCekIsT0FBTzBCLFdBQXhCO0FBQ0FqQixXQUFPa0IsUUFBUCxDQUFnQjNCLE9BQU80QixVQUF2QjtBQUNBbkIsV0FBT29CLFNBQVA7QUFDSDtBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEk7Ozs7Ozs7QUN0REE7Ozs7O2tCQU13QkMsUzs7QUFKeEI7O0FBRUEsSUFBTUMsYUFBYSxFQUFuQjs7QUFFZSxTQUFTRCxTQUFULENBQW1CN0MsR0FBbkIsRUFBd0JvQyxLQUF4QixFQUErQjtBQUFBLGVBQ25CQSxNQUFNVyxDQUFOLENBQVFDLE9BQVIsR0FBa0JaLE1BQU1XLENBQU4sQ0FBUUMsT0FBUixDQUFnQixDQUFoQixDQUFsQixHQUF1Q1osTUFBTVcsQ0FEMUI7QUFBQSxRQUNwQ0UsS0FEb0MsUUFDcENBLEtBRG9DO0FBQUEsUUFDN0JDLEtBRDZCLFFBQzdCQSxLQUQ2Qjs7QUFFMUMsUUFBSSxDQUFDZCxNQUFNZSxNQUFYLEVBQW1CO0FBQ2YsWUFBSUMsU0FBUyxDQUFDLEVBQWQ7QUFDQSxZQUFJQyxTQUFTLGtCQUFiO0FBQ0EsWUFBSUMsV0FBVztBQUNYMUQsZUFBSXFELFFBQVFILFVBREQ7QUFFWGpELGVBQUlxRCxRQUFRSjtBQUZELFNBQWY7QUFJQVMsa0JBQVU7QUFDTjNELGVBQUcwRCxTQUFTMUQsQ0FETjtBQUVOQyxlQUFHeUQsU0FBU3pELENBRk47QUFHTnlCLG1CQUFPdEIsSUFBSUMsS0FBSixDQUFVbUIsV0FBVixDQUFzQkUsS0FIdkI7QUFJTkUsb0JBQVF4QixJQUFJd0IsTUFKTjtBQUtONkI7QUFMTSxTQUFWO0FBT0EsWUFBSWpDLGNBQWNwQixJQUFJQyxLQUFKLENBQVVtQixXQUE1QjtBQUNBcEIsWUFBSUMsS0FBSixDQUFVZ0IsS0FBVixDQUFnQnVDLElBQWhCLENBQXFCO0FBQ2pCbEMsbUJBQU9GLFlBQVlFLEtBREY7QUFFakJtQyxvQkFBUUgsUUFGUztBQUdqQmpDLG9CQUFRRCxZQUFZQyxNQUhIO0FBSWpCZ0M7QUFKaUIsU0FBckI7QUFNQSxlQUFPO0FBQ0h6RCxlQUFHMEQsU0FBUzFELENBRFQ7QUFFSEMsZUFBR3lELFNBQVN6RCxDQUZUO0FBR0h3RDtBQUhHLFNBQVA7QUFLSDtBQUNKOztBQUVELFNBQVNFLFNBQVQsUUFBa0Q7QUFBQSxRQUE5QjNELENBQThCLFNBQTlCQSxDQUE4QjtBQUFBLFFBQTNCQyxDQUEyQixTQUEzQkEsQ0FBMkI7QUFBQSxRQUF4QnlCLEtBQXdCLFNBQXhCQSxLQUF3QjtBQUFBLFFBQWpCRSxNQUFpQixTQUFqQkEsTUFBaUI7QUFBQSxRQUFUNkIsTUFBUyxTQUFUQSxNQUFTOztBQUM5QztBQUNBLFFBQUlLLFNBQVMsSUFBSWhDLE9BQU9pQyxNQUFYLENBQWtCO0FBQzNCQyxjQUFNaEUsQ0FEcUI7QUFFM0JpRSxhQUFLaEUsQ0FGc0I7QUFHM0JpRSxnQkFBUWhCLFVBSG1CO0FBSTNCaUIsY0FBTXpDLEtBSnFCO0FBSzNCUSxxQkFBYSxLQUxjO0FBTTNCa0MsWUFBSVg7QUFOdUIsS0FBbEIsQ0FBYjtBQVFBN0IsV0FBT3lDLEdBQVAsQ0FBV1AsTUFBWDtBQUNILEM7Ozs7Ozs7QUNoREQ7QUFDQTs7Ozs7Ozs7QUFFQTs7OztBQUVBLElBQU1RLGNBQWMsU0FBZEEsV0FBYyxHQUFNO0FBQUUsV0FBTyxFQUFFdEUsR0FBRSxJQUFKLEVBQVVDLEdBQUUsSUFBWixFQUFrQndELFFBQU8sRUFBekIsRUFBUDtBQUF1QyxDQUFuRTtBQUNBLElBQUlmLFVBQVU0QixhQUFkO0FBQ0EsSUFBSTNCLGNBQWMyQixhQUFsQjs7SUFFcUJDLFk7QUFDakIsMEJBQVluRSxHQUFaLEVBQWlCO0FBQUE7O0FBQ2I7QUFDQSxhQUFLaUIsS0FBTCxHQUFhakIsSUFBSUMsS0FBSixDQUFVZ0IsS0FBdkI7QUFDSDs7QUFFRDs7Ozs7NENBa0I4QjtBQUFBOztBQUFBLGdCQUFmckIsQ0FBZSxRQUFmQSxDQUFlO0FBQUEsZ0JBQVpDLENBQVksUUFBWkEsQ0FBWTtBQUFBLGdCQUFUd0QsTUFBUyxRQUFUQSxNQUFTOztBQUMxQixnQkFBSUksU0FBUyxFQUFFN0QsSUFBRixFQUFLQyxJQUFMLEVBQWI7QUFDQSxpQkFBS29CLEtBQUwsQ0FBV21ELE9BQVgsQ0FBbUIsbUJBQVc7QUFDMUIsb0JBQUlmLFdBQVdnQixRQUFRaEIsTUFBdkIsRUFBK0I7O0FBRS9CLG9CQUFJLDBCQUFjLE1BQUtmLE9BQW5CLENBQUosRUFBaUM7QUFDN0IsMEJBQUtBLE9BQUwsR0FBZWdDLE9BQU9DLE1BQVAsQ0FBYyxFQUFFbEIsUUFBUWdCLFFBQVFoQixNQUFsQixFQUFkLEVBQTBDZ0IsUUFBUVosTUFBbEQsQ0FBZjtBQUNILGlCQUZELE1BRU8sSUFBSWUsU0FBU2YsTUFBVCxFQUFpQixNQUFLbkIsT0FBdEIsSUFBaUNrQyxTQUFTZixNQUFULEVBQWlCWSxRQUFRWixNQUF6QixDQUFyQyxFQUF1RTtBQUN0RSwwQkFBS2xCLFdBQUwsR0FBbUIsTUFBS0QsT0FBeEI7QUFDQSwwQkFBS0EsT0FBTCxHQUFlZ0MsT0FBT0MsTUFBUCxDQUFjLEVBQUVsQixRQUFRZ0IsUUFBUWhCLE1BQWxCLEVBQWQsRUFBMENnQixRQUFRWixNQUFsRCxDQUFmO0FBQ1AsaUJBSE0sTUFHQSxJQUFJLDBCQUFjLE1BQUtsQixXQUFuQixLQUNBaUMsU0FBU2YsTUFBVCxFQUFpQixNQUFLbEIsV0FBdEIsSUFBcUNpQyxTQUFTZixNQUFULEVBQWlCWSxRQUFRWixNQUF6QixDQUR6QyxFQUMyRTs7QUFFOUUsMEJBQUtsQixXQUFMLEdBQW1CK0IsT0FBT0MsTUFBUCxDQUFjLEVBQUVsQixRQUFRZ0IsUUFBUWhCLE1BQWxCLEVBQWQsRUFBMENnQixRQUFRWixNQUFsRCxDQUFuQjtBQUNIO0FBQ0osYUFiRDtBQWNBLG1CQUFPO0FBQ0huQix5QkFBUyxLQUFLQSxPQURYO0FBRUhDLDZCQUFhLEtBQUtBO0FBRmYsYUFBUDtBQUlIOzs7NEJBckNhO0FBQ1YsbUJBQU9ELE9BQVA7QUFDSCxTO2lDQUMyQjtBQUFBLGdCQUFmMUMsQ0FBZSxTQUFmQSxDQUFlO0FBQUEsZ0JBQVpDLENBQVksU0FBWkEsQ0FBWTtBQUFBLGdCQUFUd0QsTUFBUyxTQUFUQSxNQUFTOztBQUN4QmYsb0JBQVExQyxDQUFSLEdBQVlBLENBQVo7QUFDQTBDLG9CQUFRekMsQ0FBUixHQUFZQSxDQUFaO0FBQ0F5QyxvQkFBUWUsTUFBUixHQUFpQkEsTUFBakI7QUFDSDs7OzRCQUNpQjtBQUNkLG1CQUFPZCxXQUFQO0FBQ0gsUztpQ0FDK0I7QUFBQSxnQkFBZjNDLENBQWUsU0FBZkEsQ0FBZTtBQUFBLGdCQUFaQyxDQUFZLFNBQVpBLENBQVk7QUFBQSxnQkFBVHdELE1BQVMsU0FBVEEsTUFBUzs7QUFDNUJkLHdCQUFZM0MsQ0FBWixHQUFnQkEsQ0FBaEI7QUFDQTJDLHdCQUFZMUMsQ0FBWixHQUFnQkEsQ0FBaEI7QUFDQTBDLHdCQUFZYyxNQUFaLEdBQXFCQSxNQUFyQjtBQUNIOzs7Ozs7a0JBdEJnQmMsWTs7O0FBK0NyQixTQUFTSyxRQUFULGVBQThDO0FBQUEsUUFBekJDLEVBQXlCLFNBQTNCN0UsQ0FBMkI7QUFBQSxRQUFuQjhFLEVBQW1CLFNBQXJCN0UsQ0FBcUI7QUFBQSxRQUFYOEUsRUFBVyxTQUFiL0UsQ0FBYTtBQUFBLFFBQUxnRixFQUFLLFNBQVAvRSxDQUFPOztBQUMxQyxXQUFPVixLQUFLTyxJQUFMLENBQ0hQLEtBQUtRLEdBQUwsQ0FBVThFLEtBQUtFLEVBQWYsRUFBb0IsQ0FBcEIsSUFBeUJ4RixLQUFLUSxHQUFMLENBQVUrRSxLQUFLRSxFQUFmLEVBQW9CLENBQXBCLENBRHRCLENBQVA7QUFHSCxDOzs7Ozs7O0FDNUREO0FBQ0E7Ozs7O2tCQVF3QkMsUTs7QUFOeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDZSxTQUFTQSxRQUFULENBQWtCN0UsR0FBbEIsRUFBdUJvQyxLQUF2QixFQUE4QjBDLFNBQTlCLEVBQXlDQyxPQUF6QyxFQUFrRDtBQUFFO0FBQy9ELFFBQUksMEJBQWNBLE9BQWQsQ0FBSixFQUE0Qjs7QUFFaEMxRSxZQUFRQyxHQUFSLENBQVksV0FBWixFQUF5QndFLFNBQXpCO0FBQ0F6RSxZQUFRQyxHQUFSLENBQVksU0FBWixFQUF1QnlFLE9BQXZCO0FBQ0ksUUFBSUMsWUFBWSxTQUFoQjtBQUNBLFFBQUl2QixTQUFTLENBQ1RxQixVQUFVbEYsQ0FERCxFQUVUa0YsVUFBVWpGLENBRkQsRUFHVGtGLFFBQVFuRixDQUhDLEVBSVRtRixRQUFRbEYsQ0FKQyxDQUFiO0FBTUpRLFlBQVFDLEdBQVIsQ0FBWSxRQUFaLEVBQXNCbUQsTUFBdEI7O0FBRUl3QixZQUFReEIsTUFBUixFQUFnQnVCLFNBQWhCLEVBQTJCaEYsSUFBSXdCLE1BQS9CO0FBQ0g7O0FBRUQsU0FBU3lELE9BQVQsQ0FBaUJ4QixNQUFqQixFQUF5Qm5DLEtBQXpCLEVBQWdDRSxNQUFoQyxFQUF3QztBQUNwQyxRQUFJMEQsT0FBTyxJQUFJeEQsT0FBT3lELElBQVgsQ0FBZ0IxQixNQUFoQixFQUF3QjtBQUMvQjJCLGdCQUFROUQsS0FEdUI7QUFFL0IrRCxxQkFBYSxDQUZrQjtBQUcvQkMsb0JBQVk7QUFIbUIsS0FBeEIsQ0FBWDtBQUtKakYsWUFBUUMsR0FBUixDQUFZLE1BQVosRUFBb0I0RSxJQUFwQjs7QUFFSTFELFdBQU95QyxHQUFQLENBQVdpQixJQUFYO0FBQ0gsQzs7Ozs7OztBQ25DRDs7Ozs7a0JBSXdCSyxPOztBQUZ4Qjs7QUFFZSxTQUFTQSxPQUFULENBQWlCdkYsR0FBakIsRUFBc0I7QUFDakMsUUFBSXFCLFNBQVMsa0JBQWI7QUFDQSxRQUFJQyxRQUFRLHVCQUFaO0FBQ0F0QixRQUFJQyxLQUFKLENBQVVrQixLQUFWLENBQWdCRSxNQUFoQixJQUEwQixFQUFFQyxZQUFGLEVBQTFCOztBQUVBdEIsUUFBSUMsS0FBSixDQUFVbUIsV0FBVixHQUF3QjtBQUNwQkMsc0JBRG9CLEVBQ1pDO0FBRFksS0FBeEI7O0FBSUEsV0FBT3RCLEdBQVA7QUFDSCxDIiwiZmlsZSI6ImFwcC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBiZGFiMTExNTZkNGI3YzJkZDg0OCIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBmdW5jdGlvbiBzNCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gICAgcmV0dXJuIGAke3M0KCl9JHtzNCgpfS0ke3M0KCl9LSR7czQoKX0tJHtzNCgpfS0ke3M0KCl9JHtzNCgpfSR7czQoKX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tSGV4KCkge1xuICAgIHJldHVybiAnIycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTY3NzcyMTUpLnRvU3RyaW5nKDE2KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKGNvb3JkczEsIGNvb3JkczIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KChjb29yZHMxLnggLSBjb29yZHMyLngpLCAyKSArIE1hdGgucG93KChjb29yZHMxLnkgLSBjb29yZHMyLnkpLCAyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNBcmVOdWxsKG9iaikge1xuICAgIHJldHVybiBpc051bGwob2JqLngpICYmIGlzTnVsbChvYmoueSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0cy9jbGllbnQvdXRpbHMuanMiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbHMgY29uc29sZSAqL1xuXG4vLyBpbXBvcnQgJy4vckFGLXBvbHlmaWxsLmpzJztcbmltcG9ydCBzdGF0ZSBmcm9tICcuL3N0YXRlLmpzJztcbmltcG9ydCBjYW52YXNTZXR1cCBmcm9tICcuL2NhbnZhcy1zZXR1cC5qcyc7XG5pbXBvcnQgYWRkVXNlciBmcm9tICcuL2FkZC11c2VyLmpzJztcblxuLy8gbGV0IHJlbmRlcmVyO1xubGV0IGFwcCA9IHtcbiAgICBzdGF0ZSxcblxuICAgIC8vIGRyYXcoKSB7XG4gICAgICAgIC8vIGxldCB0aW1lO1xuICAgICAgICAvLyBsZXQgY29udHJvbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udHJvbHMnKTtcbiAgICAgICAgLy8gdGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIC8vIGNvbnRyb2xzLmlubmVyVGV4dCA9IGAke3RpbWUuZ2V0SG91cnMoKX06JHt0aW1lLmdldE1pbnV0ZXMoKX06JHt0aW1lLmdldFNlY29uZHMoKX0uJHt0aW1lLmdldE1pbGxpc2Vjb25kcygpfWA7XG4gICAgICAgIFxuICAgICAgICAvLyAvLyB0aGlzLnJlbmRlcmVyLmNsZWFyKCk7XG4gICAgICAgIC8vIGlmICh0aGlzLnN0YXRlLm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAvLyAgICAgdGhpcy5zdGF0ZS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAvLyAgICAgICAgIC8vIGNoZWNrIGlmIG5vZGUudXNlcklEIG1hdGNoZXMgdXNlcklEXG4gICAgICAgIC8vICAgICAgICAgLy8gaWYgc28sIHVzZSBjb29yZHMgZm9yIGNpcmNsZTsgZ2V0IG5vZGUgY29sb3IgZnJvbSBzdGF0ZS51c2VyW3VzZXJJRF0uY29sb3JcbiAgICAgICAgLy8gICAgIH0pXG4gICAgICAgIC8vIH1cbiAgICAvLyB9LFxufTtcblxuUHJvbWlzZS5yZXNvbHZlKGFwcClcbiAgICAudGhlbihhZGRVc2VyKVxuICAgIC50aGVuKGNhbnZhc1NldHVwKVxuICAgIC8vIC50aGVuKCgpID0+IGFuaW1hdGUoKSlcbiAgICAudGhlbigoKSA9PiBjb25zb2xlLmxvZyhcInN0YXRlXCIsIHN0YXRlKSlcbiAgICAuY2F0Y2godGhyb3duID0+IGNvbnNvbGUuZXJyb3IoJyVjQW4gZXJyb3Igb2NjdXJyZWQ6JywgJ2ZvbnQtd2VpZ2h0OmJvbGQnLCB0aHJvd24pKVxuO1xuXG4vLyBmdW5jdGlvbiBhbmltYXRlKCkge1xuLy8gICAgIGFwcC5kcmF3KCk7XG4vLyAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuLy8gfVxuZnVuY3Rpb24gb3V0cHV0KHN0cikge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvdXRwdXQnKS5pbm5lckhUTUwgKz0gYDxicj4ke3N0cn1gO1xufVxud2luZG93LmdldFN0YXRlID0gKCkgPT4gY29uc29sZS5sb2coJ2FwcC5zdGF0ZScsIGFwcC5zdGF0ZSk7XG4vKlxuVE9ETzogZ2V0IHRvdWNoLWFkZCB3b3JraW5nXG4tLSBjcmVhdGUgbm9kZSB1c2luZyB1c2VyJ3MgY29sb3Jcbi0tIHNhdmUgbm9kZSBpbmZvIHRvIG5vZGVzIGFycmF5XG5UT0RPOiBzaGFyZSBzdGF0ZSBvdmVyIHdlYnNvY2tldHNcblRPRE86IHVwZGF0ZSBzdGF0ZSBvYmplY3Qgd2hlbiBzb2NrZXQgaW5mbyBjb21lcyBpblxuICovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0cy9jbGllbnQvbWFpbi5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBUaGUgVHJ1dGghXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgbm9kZXM6IFtdLFxuICAgIGNvbm5lY3Rpb25zOiBbXSxcbiAgICB1c2Vyczoge30sXG4gICAgY3VycmVudFVzZXI6IHtcbiAgICAgICAgdXNlcklEOiAnJyxcbiAgICAgICAgY29sb3I6ICcnXG4gICAgfVxufTtcblxuLypcbmUuZy4gXG57XG4gICAgbm9kZXM6IFt7XG4gICAgICAgIHVzZXJJRDogJ2d1aWQnLFxuICAgICAgICBjb29yZHM6IFt7IHg6MCwgeTowIH1dLFxuICAgICAgICBub2RlSUQ6ICdndWlkJ1xuICAgIH1dLFxuICAgIGNvbm5lY3Rpb25zOiBbe1xuICAgICAgICBlMTogeyB4OjAsIHk6MCB9LFxuICAgICAgICBlMjogeyB4OjAsIHk6MCB9LFxuICAgIH1dLFxuICAgIHVzZXJzOiB7XG4gICAgICAgIGd1aWQ6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnJ1xuICAgICAgICB9XG4gICAgfVxufVxuICovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0cy9jbGllbnQvc3RhdGUuanMiLCJcInVzZSBzdHJpY3RcIjtcbi8qICAqL1xuaW1wb3J0IHNwYXduTm9kZSBmcm9tICcuL3NwYXduLW5vZGUuanMnO1xuaW1wb3J0IE5lYXJlc3ROb2RlcyBmcm9tICcuL2ZpbmQtbmVhcmVzdC1ub2Rlcy5qcyc7XG5pbXBvcnQgZHJhd0xpbmUgZnJvbSAnLi9kcmF3LWxpbmUuanMnO1xuXG5sZXQgY2FudmFzO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYW52YXNTZXR1cChhcHApIHtcbiAgICBjb25zdCBuZWFyZXN0Tm9kZXMgPSBuZXcgTmVhcmVzdE5vZGVzKGFwcCk7XG4gICAgY2FudmFzID0gbmV3IGZhYnJpYy5DYW52YXMoJ3N0YWdlJyk7XG5cbiAgICBmYWJyaWMuR3JvdXAucHJvdG90eXBlLmhhc0NvbnRyb2xzID0gZmFsc2U7XG4gICAgY2FudmFzLnNlbGVjdGlvbiA9IGZhbHNlO1xuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVDYW52YXMsIGZhbHNlKTtcbiAgICByZXNpemVDYW52YXMoKTtcbiAgICBhcHAucmVzaXplQ2FudmFzID0gcmVzaXplQ2FudmFzO1xuICAgIGFwcC5jYW52YXMgPSBjYW52YXM7XG5cbiAgICBjYW52YXMub24oe1xuICAgICAgICAnbW91c2U6ZG93bic6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGxldCBub2RlID0gc3Bhd25Ob2RlKGFwcCwgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSBuZWFyZXN0Tm9kZXMuZmluZENsb3Nlc3RUbyhub2RlKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vZGVzXCIsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgJ2Nsb3Nlc3QnLCBub2Rlcy5jbG9zZXN0LFxuICAgICAgICAgICAgICAgICAgICAnbmV4dENsb3Nlc3QnLCBub2Rlcy5uZXh0Q2xvc2VzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gZHJhdyBsaW5lc1xuICAgICAgICAgICAgICAgIC8vIGRyYXcgbGluZSBmcm9tIG5vZGUueHkgdG8gY2xvc2VzdC54eVxuICAgICAgICAgICAgICAgIC8vIGRyYXcgbGluZSBmcm9tIG5vZGUueHkgdG8gbmV4dENsb3Nlc3QueHlcbiAgICAgICAgICAgICAgICAvLyBzYXZlIGRyYXduIGxpbmVzIHRvIGNvbm5lY3Rpb25zIGluIHN0YXRlXG5cbiAgICAgICAgICAgICAgICBkcmF3TGluZShhcHAsIGV2ZW50LCBub2RlLCBub2Rlcy5jbG9zZXN0KTtcbiAgICAgICAgICAgICAgICBkcmF3TGluZShhcHAsIGV2ZW50LCBub2RlLCBub2Rlcy5uZXh0Q2xvc2VzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhcHA7XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZUNhbnZhcygpIHtcbiAgICBjYW52YXMuc2V0SGVpZ2h0KHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgY2FudmFzLnNldFdpZHRoKHdpbmRvdy5pbm5lcldpZHRoKTtcbiAgICBjYW52YXMucmVuZGVyQWxsKCk7XG59XG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYW52YXNTZXR1cChhcHApIHtcbi8vICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YWdlJyk7XG4vLyAgICAgYXBwLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKGNhbnZhcyk7XG5cbi8vICAgICByZXR1cm4gYXBwO1xuLy8gfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NjcmlwdHMvY2xpZW50L2NhbnZhcy1zZXR1cC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBndWlkIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmNvbnN0IG5vZGVSYWRpdXMgPSA1MDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3Bhd25Ob2RlKGFwcCwgZXZlbnQpIHtcbiAgICBsZXQgeyBwYWdlWCwgcGFnZVkgfSA9IGV2ZW50LmUudG91Y2hlcyA/IGV2ZW50LmUudG91Y2hlc1swXSA6IGV2ZW50LmU7XG4gICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IC0yMDtcbiAgICAgICAgbGV0IG5vZGVJRCA9IGd1aWQoKTtcbiAgICAgICAgbGV0IGNlbnRlcmVkID0ge1xuICAgICAgICAgICAgeDogKHBhZ2VYIC0gbm9kZVJhZGl1cyksXG4gICAgICAgICAgICB5OiAocGFnZVkgLSBub2RlUmFkaXVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgYWRkQ2lyY2xlKHtcbiAgICAgICAgICAgIHg6IGNlbnRlcmVkLngsXG4gICAgICAgICAgICB5OiBjZW50ZXJlZC55LFxuICAgICAgICAgICAgY29sb3I6IGFwcC5zdGF0ZS5jdXJyZW50VXNlci5jb2xvcixcbiAgICAgICAgICAgIGNhbnZhczogYXBwLmNhbnZhcyxcbiAgICAgICAgICAgIG5vZGVJRFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGN1cnJlbnRVc2VyID0gYXBwLnN0YXRlLmN1cnJlbnRVc2VyO1xuICAgICAgICBhcHAuc3RhdGUubm9kZXMucHVzaCh7XG4gICAgICAgICAgICBjb2xvcjogY3VycmVudFVzZXIuY29sb3IsXG4gICAgICAgICAgICBjb29yZHM6IGNlbnRlcmVkLFxuICAgICAgICAgICAgdXNlcklEOiBjdXJyZW50VXNlci51c2VySUQsXG4gICAgICAgICAgICBub2RlSURcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBjZW50ZXJlZC54LFxuICAgICAgICAgICAgeTogY2VudGVyZWQueSxcbiAgICAgICAgICAgIG5vZGVJRFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkQ2lyY2xlKHt4LCB5LCBjb2xvciwgY2FudmFzLCBub2RlSUR9KSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJ4LCB5LCBjb2xvciwgY2FudmFzXCIsIHgsIHksIGNvbG9yLCBjYW52YXMpO1xuICAgIGxldCBjaXJjbGUgPSBuZXcgZmFicmljLkNpcmNsZSh7XG4gICAgICAgIGxlZnQ6IHgsXG4gICAgICAgIHRvcDogeSxcbiAgICAgICAgcmFkaXVzOiBub2RlUmFkaXVzLFxuICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgaGFzQ29udHJvbHM6IGZhbHNlLFxuICAgICAgICBpZDogbm9kZUlEXG4gICAgfSk7XG4gICAgY2FudmFzLmFkZChjaXJjbGUpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NjcmlwdHMvY2xpZW50L3NwYXduLW5vZGUuanMiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbHMgTWF0aCAqL1xuXG5pbXBvcnQgeyBjb29yZHNBcmVOdWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmNvbnN0IGVtcHR5Q29vcmRzID0gKCkgPT4geyByZXR1cm4geyB4Om51bGwsIHk6bnVsbCwgbm9kZUlEOicnIH07IH07XG5sZXQgY2xvc2VzdCA9IGVtcHR5Q29vcmRzKCk7XG5sZXQgbmV4dENsb3Nlc3QgPSBlbXB0eUNvb3JkcygpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZWFyZXN0Tm9kZXMge1xuICAgIGNvbnN0cnVjdG9yKGFwcCkge1xuICAgICAgICAvLyB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5ub2RlcyA9IGFwcC5zdGF0ZS5ub2RlcztcbiAgICB9XG5cbiAgICAvLyBvbmx5IHVzaW5nIGdldHRlci9zZXR0ZXIgcGF0dGVybiBpbiBjYXNlIEkgcGFzcyBvYmplY3QgdG8gc2V0IGNvb3JkcyBhbmQgaXQgaGFzIG1vcmUgdGhhbiB4L3lcbiAgICBnZXQgY2xvc2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3Q7XG4gICAgfVxuICAgIHNldCBjbG9zZXN0KHt4LCB5LCBub2RlSUR9KSB7XG4gICAgICAgIGNsb3Nlc3QueCA9IHg7XG4gICAgICAgIGNsb3Nlc3QueSA9IHk7XG4gICAgICAgIGNsb3Nlc3Qubm9kZUlEID0gbm9kZUlEO1xuICAgIH1cbiAgICBnZXQgbmV4dENsb3Nlc3QoKSB7XG4gICAgICAgIHJldHVybiBuZXh0Q2xvc2VzdDtcbiAgICB9XG4gICAgc2V0IG5leHRDbG9zZXN0KHt4LCB5LCBub2RlSUR9KSB7XG4gICAgICAgIG5leHRDbG9zZXN0LnggPSB4O1xuICAgICAgICBuZXh0Q2xvc2VzdC55ID0geTtcbiAgICAgICAgbmV4dENsb3Nlc3Qubm9kZUlEID0gbm9kZUlEO1xuICAgIH1cblxuICAgIGZpbmRDbG9zZXN0VG8oe3gsIHksIG5vZGVJRH0pIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHsgeCwgeSB9O1xuICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2godG1wTm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZUlEID09PSB0bXBOb2RlLm5vZGVJRCkgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoY29vcmRzQXJlTnVsbCh0aGlzLmNsb3Nlc3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZXN0ID0gT2JqZWN0LmFzc2lnbih7IG5vZGVJRDogdG1wTm9kZS5ub2RlSUQgfSwgdG1wTm9kZS5jb29yZHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZShjb29yZHMsIHRoaXMuY2xvc2VzdCkgPiBkaXN0YW5jZShjb29yZHMsIHRtcE5vZGUuY29vcmRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRDbG9zZXN0ID0gdGhpcy5jbG9zZXN0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3Nlc3QgPSBPYmplY3QuYXNzaWduKHsgbm9kZUlEOiB0bXBOb2RlLm5vZGVJRCB9LCB0bXBOb2RlLmNvb3Jkcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvb3Jkc0FyZU51bGwodGhpcy5uZXh0Q2xvc2VzdCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlKGNvb3JkcywgdGhpcy5uZXh0Q2xvc2VzdCkgPiBkaXN0YW5jZShjb29yZHMsIHRtcE5vZGUuY29vcmRzKSkge1xuXG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2xvc2VzdCA9IE9iamVjdC5hc3NpZ24oeyBub2RlSUQ6IHRtcE5vZGUubm9kZUlEIH0sIHRtcE5vZGUuY29vcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbG9zZXN0OiB0aGlzLmNsb3Nlc3QsXG4gICAgICAgICAgICBuZXh0Q2xvc2VzdDogdGhpcy5uZXh0Q2xvc2VzdCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpc3RhbmNlKHt4OngxLCB5OnkxfSwge3g6eDIsIHk6eTJ9KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgTWF0aC5wb3coKHgxIC0geDIpLCAyKSArIE1hdGgucG93KCh5MSAtIHkyKSwgMilcbiAgICApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NjcmlwdHMvY2xpZW50L2ZpbmQtbmVhcmVzdC1ub2Rlcy5qcyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFscyBjb25zb2xlICovXG5cbmltcG9ydCB7IGNvb3Jkc0FyZU51bGwgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLy8gVGhpbmdzIG5lZWRlZCB0byBkcmF3IGxpbmVzXG4vLyAtIGNvbG9yXG4vLyAtIHN0YXJ0IHBvaW50IChjb29yZHMgJiBwYXJlbnQgY2lyY2xlIElEKVxuLy8gLSBlbmQgcG9pbnQgKGNvb3JkcyAmIHBhcmVudCBjaXJjbGUgSUQpXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkcmF3TGluZShhcHAsIGV2ZW50LCBzdGFydE5vZGUsIGVuZE5vZGUpIHsgLy8gVE9ETyByZW1vdmUgZXZlbnQgcGFyYW0/XG4gICAgaWYgKGNvb3Jkc0FyZU51bGwoZW5kTm9kZSkpIHJldHVybjtcblxuY29uc29sZS5sb2coXCJzdGFydE5vZGVcIiwgc3RhcnROb2RlKTtcbmNvbnNvbGUubG9nKFwiZW5kTm9kZVwiLCBlbmROb2RlKTtcbiAgICBsZXQgbGluZUNvbG9yID0gJyMwMDAwMDAnO1xuICAgIGxldCBjb29yZHMgPSBbXG4gICAgICAgIHN0YXJ0Tm9kZS54LFxuICAgICAgICBzdGFydE5vZGUueSxcbiAgICAgICAgZW5kTm9kZS54LFxuICAgICAgICBlbmROb2RlLnksXG4gICAgXTtcbmNvbnNvbGUubG9nKFwiY29vcmRzXCIsIGNvb3Jkcyk7XG5cbiAgICBhZGRMaW5lKGNvb3JkcywgbGluZUNvbG9yLCBhcHAuY2FudmFzKTtcbn1cblxuZnVuY3Rpb24gYWRkTGluZShjb29yZHMsIGNvbG9yLCBjYW52YXMpIHtcbiAgICBsZXQgbGluZSA9IG5ldyBmYWJyaWMuTGluZShjb29yZHMsIHtcbiAgICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDUsXG4gICAgICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgIH0pO1xuY29uc29sZS5sb2coXCJsaW5lXCIsIGxpbmUpO1xuXG4gICAgY2FudmFzLmFkZChsaW5lKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9kcmF3LWxpbmUuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgZ3VpZCwgcmFuZG9tSGV4IH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZFVzZXIoYXBwKSB7XG4gICAgbGV0IHVzZXJJRCA9IGd1aWQoKTtcbiAgICBsZXQgY29sb3IgPSByYW5kb21IZXgoKTtcbiAgICBhcHAuc3RhdGUudXNlcnNbdXNlcklEXSA9IHsgY29sb3IgfTtcblxuICAgIGFwcC5zdGF0ZS5jdXJyZW50VXNlciA9IHtcbiAgICAgICAgdXNlcklELCBjb2xvclxuICAgIH07XG5cbiAgICByZXR1cm4gYXBwO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9hZGQtdXNlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=