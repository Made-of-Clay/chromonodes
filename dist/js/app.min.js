/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.guid = guid;
exports.randomHex = randomHex;
exports.getDistance = getDistance;
exports.isNull = isNull;
exports.isArray = isArray;
exports.coordsAreNull = coordsAreNull;
function guid() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    // return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    return "" + s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
}

function randomHex() {
    return '#' + Math.floor(Math.random() * 16777215).toString(16);
}

function getDistance(coords1, coords2) {
    return Math.sqrt(Math.pow(coords1.x - coords2.x, 2) + Math.pow(coords1.y - coords2.y, 2));
}

function isNull(value) {
    return value === null;
}
function isArray(value) {
    return Array.isArray(value);
}

function coordsAreNull(obj) {
    return isNull(obj.x) && isNull(obj.y);
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals console */

// import './rAF-polyfill.js';

var _state = __webpack_require__(2);

var _state2 = _interopRequireDefault(_state);

var _canvasSetup = __webpack_require__(3);

var _canvasSetup2 = _interopRequireDefault(_canvasSetup);

var _addUser = __webpack_require__(7);

var _addUser2 = _interopRequireDefault(_addUser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// let renderer;
var app = {
    state: _state2.default

    // draw() {
    // let time;
    // let controls = document.getElementById('controls');
    // time = new Date();
    // controls.innerText = `${time.getHours()}:${time.getMinutes()}:${time.getSeconds()}.${time.getMilliseconds()}`;

    // // this.renderer.clear();
    // if (this.state.nodes.length) {
    //     this.state.nodes.forEach(node => {
    //         // check if node.userID matches userID
    //         // if so, use coords for circle; get node color from state.user[userID].color
    //     })
    // }
    // },
};

Promise.resolve(app).then(_addUser2.default).then(_canvasSetup2.default)
// .then(() => animate())
.then(function () {
    return console.log("state", _state2.default);
}).catch(function (thrown) {
    return console.error('%cAn error occurred:', 'font-weight:bold', thrown);
});

// function animate() {
//     app.draw();
//     requestAnimationFrame(animate);
// }
function output(str) {
    document.getElementById('output').innerHTML += '<br>' + str;
}
window.getState = function () {
    return console.log('app.state', app.state);
};
/*
TODO: get touch-add working
-- create node using user's color
-- save node info to nodes array
TODO: share state over websockets
TODO: update state object when socket info comes in
 */

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// The Truth!

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    // nodes: [],
    nodes: {},
    connections: [],
    users: {},
    currentUser: {
        userID: '',
        color: ''
    }
};

/*
e.g. 
{
    nodes: [{ // ORIG
        userID: 'guid',
        coords: [{ x:0, y:0 }],
        nodeID: 'guid'
    }],
    nodes: { // ALT
        nodeID: {
            userID: 'guid',
            coords: [{ x:0, y:0 }],
            color: ''
        }
    },
    connections: [{
        e1: { x:0, y:0 },
        e2: { x:0, y:0 },
    }],
    users: {
        guid: {
            color: ''
        }
    }
}
 */

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*  */

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = canvasSetup;

var _spawnNode = __webpack_require__(4);

var _spawnNode2 = _interopRequireDefault(_spawnNode);

var _findNearestNodes = __webpack_require__(5);

var _findNearestNodes2 = _interopRequireDefault(_findNearestNodes);

var _drawLine = __webpack_require__(6);

var _drawLine2 = _interopRequireDefault(_drawLine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var canvas = void 0;function canvasSetup(app) {
    var nearestNodes = new _findNearestNodes2.default(app);
    canvas = new fabric.Canvas('stage');

    fabric.Group.prototype.hasControls = false;
    canvas.selection = false;

    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas();
    app.resizeCanvas = resizeCanvas;
    app.canvas = canvas;

    canvas.on({
        'mouse:down': function mouseDown(event) {
            var node = (0, _spawnNode2.default)(app, event);
            if (node) {
                var nodes = nearestNodes.findClosestTo(node);
                console.log("nodes", nodes);
                console.log('closest', nodes.closest, 'nextClosest', nodes.nextClosest);

                var closestLine = (0, _drawLine2.default)(app, event, node, nodes.closest);
                // app.state.nodes[node.nodeID].
                var nextClosestLine = (0, _drawLine2.default)(app, event, node, nodes.nextClosest);
            }
        }
    });
    // object:move gives object as e.target (check that it's a node)
    // get node from app.state[node.nodeID]
    // loop node.lines (array of objects)
    // each line: get app.state.connections[lineID]
    // update matched line according to node.lines[x].point (start|end)

    return app;
}

function resizeCanvas() {
    canvas.setHeight(window.innerHeight);
    canvas.setWidth(window.innerWidth);
    canvas.renderAll();
}
// export default function canvasSetup(app) {
//     let canvas = document.getElementById('stage');
//     app.renderer = new Renderer(canvas);

//     return app;
// }

////////////////////////////////////////
///
///   0-------O         0 = start   O = end
/// 
/// line properties: x1, y1, startNodeID, x2, y2, endNodeID, lineID (color, stroke, etc...)
/// When some node updates position, use lineID (stored on node?)
/// to fetch line from store (by lineID) and update it's x/y
///


//////////////////// ALT //////////////////////
///
/// circle created
///

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = spawnNode;

var _utils = __webpack_require__(0);

var nodeRadius = 50;

function spawnNode(app, event) {
    var _ref = event.e.touches ? event.e.touches[0] : event.e,
        pageX = _ref.pageX,
        pageY = _ref.pageY;

    if (!event.target) {
        var offset = -20;
        var nodeID = (0, _utils.guid)();
        var centered = {
            x: pageX - nodeRadius,
            y: pageY - nodeRadius
        };
        addCircle({
            x: centered.x,
            y: centered.y,
            color: app.state.currentUser.color,
            canvas: app.canvas,
            nodeID: nodeID
        });
        var currentUser = app.state.currentUser;
        // app.state.nodes.push({
        //     color: currentUser.color,
        //     coords: centered,
        //     userID: currentUser.userID,
        //     nodeID
        // });
        app.state.nodes[nodeID] = {
            color: currentUser.color,
            coords: centered,
            userID: currentUser.userID
        };
        return {
            x: centered.x,
            y: centered.y,
            nodeID: nodeID
        };
    }
}

function addCircle(_ref2) {
    var x = _ref2.x,
        y = _ref2.y,
        color = _ref2.color,
        canvas = _ref2.canvas,
        nodeID = _ref2.nodeID;

    // console.log("x, y, color, canvas", x, y, color, canvas);
    var circle = new fabric.Circle({
        left: x,
        top: y,
        radius: nodeRadius,
        fill: color,
        hasControls: false,
        id: nodeID
    });
    canvas.add(circle);
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals Math */

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var emptyCoords = function emptyCoords() {
    return { x: null, y: null, nodeID: '' };
};
var closest = emptyCoords();
var nextClosest = emptyCoords();

var NearestNodes = function () {
    function NearestNodes(app) {
        _classCallCheck(this, NearestNodes);

        // this.app = app;
        this.nodes = app.state.nodes;
    }

    // only using getter/setter pattern in case I pass object to set coords and it has more than x/y


    _createClass(NearestNodes, [{
        key: 'findClosestTo',
        value: function findClosestTo(_ref) {
            var x = _ref.x,
                y = _ref.y,
                nodeID = _ref.nodeID;

            var coords = { x: x, y: y };
            var self = this;

            for (var key in this.nodes) {
                loopAction(this.nodes[key]);
            }

            // this.nodes.forEach(tmpNode => {
            function loopAction(tmpNode) {
                if (nodeID === tmpNode.nodeID) return;

                if ((0, _utils.coordsAreNull)(self.closest)) {
                    self.closest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                } else if (distance(coords, self.closest) > distance(coords, tmpNode.coords)) {
                    self.nextClosest = self.closest;
                    self.closest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                } else if ((0, _utils.coordsAreNull)(self.nextClosest) || distance(coords, self.nextClosest) > distance(coords, tmpNode.coords)) {

                    self.nextClosest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                }
            }
            // });
            return {
                closest: this.closest,
                nextClosest: this.nextClosest
            };
        }
    }, {
        key: 'closest',
        get: function get() {
            return closest;
        },
        set: function set(_ref2) {
            var x = _ref2.x,
                y = _ref2.y,
                nodeID = _ref2.nodeID;

            closest.x = x;
            closest.y = y;
            closest.nodeID = nodeID;
        }
    }, {
        key: 'nextClosest',
        get: function get() {
            return nextClosest;
        },
        set: function set(_ref3) {
            var x = _ref3.x,
                y = _ref3.y,
                nodeID = _ref3.nodeID;

            nextClosest.x = x;
            nextClosest.y = y;
            nextClosest.nodeID = nodeID;
        }
    }]);

    return NearestNodes;
}();

exports.default = NearestNodes;


function distance(_ref4, _ref5) {
    var x1 = _ref4.x,
        y1 = _ref4.y;
    var x2 = _ref5.x,
        y2 = _ref5.y;

    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals console */

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = drawLine;

var _utils = __webpack_require__(0);

// Things needed to draw lines
// - color
// - start point (coords & parent circle ID)
// - end point (coords & parent circle ID)
function drawLine(app, event, startNode, endNode) {
    // TODO remove event param?
    if ((0, _utils.coordsAreNull)(endNode)) return;

    var lineColor = '#000000';
    var offset = 50;
    var coords = [startNode.x + offset, startNode.y + offset, endNode.x + offset, endNode.y + offset];

    var lineStore = {
        start: {
            x: startNode.x,
            y: startNode.y,
            nodeID: startNode.nodeID
        },
        end: {
            x: endNode.x,
            y: endNode.y,
            nodeID: endNode.nodeID
        }
    };
    var line = addLine(coords, lineColor, app.canvas);

    updateState(line.lineID, app.state.nodes[startNode.nodeID], app.state.nodes[endNode.nodeID]);

    return line;
}

function addLine(coords, color, canvas) {
    var line = new fabric.Line(coords, {
        id: (0, _utils.guid)(),
        stroke: color,
        strokeWidth: 5,
        selectable: false
    });

    canvas.add(line);
    canvas.sendToBack(line);
    return line;
}

function updateState(lineID, storedStartNode, storedEndNode) {
    if (!(0, _utils.isArray)(storedStartNode.lines)) {
        storedStartNode.lines = [];
    }
    if (!(0, _utils.isArray)(storedEndNode.lines)) {
        storedEndNode.lines = [];
    }
    storedStartNode.lines.push({
        lineID: line.lineID,
        point: 'start'
    });
    storedEndNode.lines.push({
        lineID: line.lineID,
        point: 'end'
    });
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addUser;

var _utils = __webpack_require__(0);

function addUser(app) {
    var userID = (0, _utils.guid)();
    var color = (0, _utils.randomHex)();
    app.state.users[userID] = { color: color };

    app.state.currentUser = {
        userID: userID, color: color
    };

    return app;
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOTIyYmE3OGI2Njc2NmIzNjM3MzEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NsaWVudC9tYWluLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NsaWVudC9zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jbGllbnQvY2FudmFzLXNldHVwLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NsaWVudC9zcGF3bi1ub2RlLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NsaWVudC9maW5kLW5lYXJlc3Qtbm9kZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L2RyYXctbGluZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jbGllbnQvYWRkLXVzZXIuanMiXSwibmFtZXMiOlsiZ3VpZCIsInJhbmRvbUhleCIsImdldERpc3RhbmNlIiwiaXNOdWxsIiwiaXNBcnJheSIsImNvb3Jkc0FyZU51bGwiLCJzNCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiY29vcmRzMSIsImNvb3JkczIiLCJzcXJ0IiwicG93IiwieCIsInkiLCJ2YWx1ZSIsIkFycmF5Iiwib2JqIiwiYXBwIiwic3RhdGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJjb25zb2xlIiwibG9nIiwiY2F0Y2giLCJlcnJvciIsInRocm93biIsIm91dHB1dCIsInN0ciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJpbm5lckhUTUwiLCJ3aW5kb3ciLCJnZXRTdGF0ZSIsIm5vZGVzIiwiY29ubmVjdGlvbnMiLCJ1c2VycyIsImN1cnJlbnRVc2VyIiwidXNlcklEIiwiY29sb3IiLCJjYW52YXNTZXR1cCIsImNhbnZhcyIsIm5lYXJlc3ROb2RlcyIsImZhYnJpYyIsIkNhbnZhcyIsIkdyb3VwIiwicHJvdG90eXBlIiwiaGFzQ29udHJvbHMiLCJzZWxlY3Rpb24iLCJhZGRFdmVudExpc3RlbmVyIiwicmVzaXplQ2FudmFzIiwib24iLCJub2RlIiwiZXZlbnQiLCJmaW5kQ2xvc2VzdFRvIiwiY2xvc2VzdCIsIm5leHRDbG9zZXN0IiwiY2xvc2VzdExpbmUiLCJuZXh0Q2xvc2VzdExpbmUiLCJzZXRIZWlnaHQiLCJpbm5lckhlaWdodCIsInNldFdpZHRoIiwiaW5uZXJXaWR0aCIsInJlbmRlckFsbCIsInNwYXduTm9kZSIsIm5vZGVSYWRpdXMiLCJlIiwidG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJ0YXJnZXQiLCJvZmZzZXQiLCJub2RlSUQiLCJjZW50ZXJlZCIsImFkZENpcmNsZSIsImNvb3JkcyIsImNpcmNsZSIsIkNpcmNsZSIsImxlZnQiLCJ0b3AiLCJyYWRpdXMiLCJmaWxsIiwiaWQiLCJhZGQiLCJlbXB0eUNvb3JkcyIsIk5lYXJlc3ROb2RlcyIsInNlbGYiLCJrZXkiLCJsb29wQWN0aW9uIiwidG1wTm9kZSIsIk9iamVjdCIsImFzc2lnbiIsImRpc3RhbmNlIiwieDEiLCJ5MSIsIngyIiwieTIiLCJkcmF3TGluZSIsInN0YXJ0Tm9kZSIsImVuZE5vZGUiLCJsaW5lQ29sb3IiLCJsaW5lU3RvcmUiLCJzdGFydCIsImVuZCIsImxpbmUiLCJhZGRMaW5lIiwidXBkYXRlU3RhdGUiLCJsaW5lSUQiLCJMaW5lIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzZWxlY3RhYmxlIiwic2VuZFRvQmFjayIsInN0b3JlZFN0YXJ0Tm9kZSIsInN0b3JlZEVuZE5vZGUiLCJsaW5lcyIsInB1c2giLCJwb2ludCIsImFkZFVzZXIiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FB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QyxLQUFKLENBQVVrQixLQUFWLENBQWdCRSxNQUFoQixJQUEwQixFQUFFQyxZQUFGLEVBQTFCOztBQUVBdEIsUUFBSUMsS0FBSixDQUFVbUIsV0FBVixHQUF3QjtBQUNwQkMsc0JBRG9CLEVBQ1pDO0FBRFksS0FBeEI7O0FBSUEsV0FBT3RCLEdBQVA7QUFDSCxDIiwiZmlsZSI6ImFwcC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA5MjJiYTc4YjY2NzY2YjM2MzczMSIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBmdW5jdGlvbiBzNCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gICAgcmV0dXJuIGAke3M0KCl9JHtzNCgpfS0ke3M0KCl9LSR7czQoKX0tJHtzNCgpfS0ke3M0KCl9JHtzNCgpfSR7czQoKX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tSGV4KCkge1xuICAgIHJldHVybiAnIycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTY3NzcyMTUpLnRvU3RyaW5nKDE2KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKGNvb3JkczEsIGNvb3JkczIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KChjb29yZHMxLnggLSBjb29yZHMyLngpLCAyKSArIE1hdGgucG93KChjb29yZHMxLnkgLSBjb29yZHMyLnkpLCAyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvb3Jkc0FyZU51bGwob2JqKSB7XG4gICAgcmV0dXJuIGlzTnVsbChvYmoueCkgJiYgaXNOdWxsKG9iai55KTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC91dGlscy5qcyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFscyBjb25zb2xlICovXG5cbi8vIGltcG9ydCAnLi9yQUYtcG9seWZpbGwuanMnO1xuaW1wb3J0IHN0YXRlIGZyb20gJy4vc3RhdGUuanMnO1xuaW1wb3J0IGNhbnZhc1NldHVwIGZyb20gJy4vY2FudmFzLXNldHVwLmpzJztcbmltcG9ydCBhZGRVc2VyIGZyb20gJy4vYWRkLXVzZXIuanMnO1xuXG4vLyBsZXQgcmVuZGVyZXI7XG5sZXQgYXBwID0ge1xuICAgIHN0YXRlLFxuXG4gICAgLy8gZHJhdygpIHtcbiAgICAgICAgLy8gbGV0IHRpbWU7XG4gICAgICAgIC8vIGxldCBjb250cm9scyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250cm9scycpO1xuICAgICAgICAvLyB0aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgLy8gY29udHJvbHMuaW5uZXJUZXh0ID0gYCR7dGltZS5nZXRIb3VycygpfToke3RpbWUuZ2V0TWludXRlcygpfToke3RpbWUuZ2V0U2Vjb25kcygpfS4ke3RpbWUuZ2V0TWlsbGlzZWNvbmRzKCl9YDtcbiAgICAgICAgXG4gICAgICAgIC8vIC8vIHRoaXMucmVuZGVyZXIuY2xlYXIoKTtcbiAgICAgICAgLy8gaWYgKHRoaXMuc3RhdGUubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vICAgICB0aGlzLnN0YXRlLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgLy8gY2hlY2sgaWYgbm9kZS51c2VySUQgbWF0Y2hlcyB1c2VySURcbiAgICAgICAgLy8gICAgICAgICAvLyBpZiBzbywgdXNlIGNvb3JkcyBmb3IgY2lyY2xlOyBnZXQgbm9kZSBjb2xvciBmcm9tIHN0YXRlLnVzZXJbdXNlcklEXS5jb2xvclxuICAgICAgICAvLyAgICAgfSlcbiAgICAgICAgLy8gfVxuICAgIC8vIH0sXG59O1xuXG5Qcm9taXNlLnJlc29sdmUoYXBwKVxuICAgIC50aGVuKGFkZFVzZXIpXG4gICAgLnRoZW4oY2FudmFzU2V0dXApXG4gICAgLy8gLnRoZW4oKCkgPT4gYW5pbWF0ZSgpKVxuICAgIC50aGVuKCgpID0+IGNvbnNvbGUubG9nKFwic3RhdGVcIiwgc3RhdGUpKVxuICAgIC5jYXRjaCh0aHJvd24gPT4gY29uc29sZS5lcnJvcignJWNBbiBlcnJvciBvY2N1cnJlZDonLCAnZm9udC13ZWlnaHQ6Ym9sZCcsIHRocm93bikpXG47XG5cbi8vIGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4vLyAgICAgYXBwLmRyYXcoKTtcbi8vICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4vLyB9XG5mdW5jdGlvbiBvdXRwdXQoc3RyKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ291dHB1dCcpLmlubmVySFRNTCArPSBgPGJyPiR7c3RyfWA7XG59XG53aW5kb3cuZ2V0U3RhdGUgPSAoKSA9PiBjb25zb2xlLmxvZygnYXBwLnN0YXRlJywgYXBwLnN0YXRlKTtcbi8qXG5UT0RPOiBnZXQgdG91Y2gtYWRkIHdvcmtpbmdcbi0tIGNyZWF0ZSBub2RlIHVzaW5nIHVzZXIncyBjb2xvclxuLS0gc2F2ZSBub2RlIGluZm8gdG8gbm9kZXMgYXJyYXlcblRPRE86IHNoYXJlIHN0YXRlIG92ZXIgd2Vic29ja2V0c1xuVE9ETzogdXBkYXRlIHN0YXRlIG9iamVjdCB3aGVuIHNvY2tldCBpbmZvIGNvbWVzIGluXG4gKi9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9tYWluLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoZSBUcnV0aCFcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICAvLyBub2RlczogW10sXG4gICAgbm9kZXM6IHt9LFxuICAgIGNvbm5lY3Rpb25zOiBbXSxcbiAgICB1c2Vyczoge30sXG4gICAgY3VycmVudFVzZXI6IHtcbiAgICAgICAgdXNlcklEOiAnJyxcbiAgICAgICAgY29sb3I6ICcnXG4gICAgfVxufTtcblxuLypcbmUuZy4gXG57XG4gICAgbm9kZXM6IFt7IC8vIE9SSUdcbiAgICAgICAgdXNlcklEOiAnZ3VpZCcsXG4gICAgICAgIGNvb3JkczogW3sgeDowLCB5OjAgfV0sXG4gICAgICAgIG5vZGVJRDogJ2d1aWQnXG4gICAgfV0sXG4gICAgbm9kZXM6IHsgLy8gQUxUXG4gICAgICAgIG5vZGVJRDoge1xuICAgICAgICAgICAgdXNlcklEOiAnZ3VpZCcsXG4gICAgICAgICAgICBjb29yZHM6IFt7IHg6MCwgeTowIH1dLFxuICAgICAgICAgICAgY29sb3I6ICcnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbm5lY3Rpb25zOiBbe1xuICAgICAgICBlMTogeyB4OjAsIHk6MCB9LFxuICAgICAgICBlMjogeyB4OjAsIHk6MCB9LFxuICAgIH1dLFxuICAgIHVzZXJzOiB7XG4gICAgICAgIGd1aWQ6IHtcbiAgICAgICAgICAgIGNvbG9yOiAnJ1xuICAgICAgICB9XG4gICAgfVxufVxuICovXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0cy9jbGllbnQvc3RhdGUuanMiLCJcInVzZSBzdHJpY3RcIjtcbi8qICAqL1xuaW1wb3J0IHNwYXduTm9kZSBmcm9tICcuL3NwYXduLW5vZGUuanMnO1xuaW1wb3J0IE5lYXJlc3ROb2RlcyBmcm9tICcuL2ZpbmQtbmVhcmVzdC1ub2Rlcy5qcyc7XG5pbXBvcnQgZHJhd0xpbmUgZnJvbSAnLi9kcmF3LWxpbmUuanMnO1xuXG5sZXQgY2FudmFzO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYW52YXNTZXR1cChhcHApIHtcbiAgICBjb25zdCBuZWFyZXN0Tm9kZXMgPSBuZXcgTmVhcmVzdE5vZGVzKGFwcCk7XG4gICAgY2FudmFzID0gbmV3IGZhYnJpYy5DYW52YXMoJ3N0YWdlJyk7XG5cbiAgICBmYWJyaWMuR3JvdXAucHJvdG90eXBlLmhhc0NvbnRyb2xzID0gZmFsc2U7XG4gICAgY2FudmFzLnNlbGVjdGlvbiA9IGZhbHNlO1xuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVDYW52YXMsIGZhbHNlKTtcbiAgICByZXNpemVDYW52YXMoKTtcbiAgICBhcHAucmVzaXplQ2FudmFzID0gcmVzaXplQ2FudmFzO1xuICAgIGFwcC5jYW52YXMgPSBjYW52YXM7XG5cbiAgICBjYW52YXMub24oe1xuICAgICAgICAnbW91c2U6ZG93bic6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGxldCBub2RlID0gc3Bhd25Ob2RlKGFwcCwgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZXMgPSBuZWFyZXN0Tm9kZXMuZmluZENsb3Nlc3RUbyhub2RlKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vZGVzXCIsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgJ2Nsb3Nlc3QnLCBub2Rlcy5jbG9zZXN0LFxuICAgICAgICAgICAgICAgICAgICAnbmV4dENsb3Nlc3QnLCBub2Rlcy5uZXh0Q2xvc2VzdFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBsZXQgY2xvc2VzdExpbmUgPSBkcmF3TGluZShhcHAsIGV2ZW50LCBub2RlLCBub2Rlcy5jbG9zZXN0KTtcbiAgICAgICAgICAgICAgICAvLyBhcHAuc3RhdGUubm9kZXNbbm9kZS5ub2RlSURdLlxuICAgICAgICAgICAgICAgIGxldCBuZXh0Q2xvc2VzdExpbmUgPSBkcmF3TGluZShhcHAsIGV2ZW50LCBub2RlLCBub2Rlcy5uZXh0Q2xvc2VzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBvYmplY3Q6bW92ZSBnaXZlcyBvYmplY3QgYXMgZS50YXJnZXQgKGNoZWNrIHRoYXQgaXQncyBhIG5vZGUpXG4gICAgLy8gZ2V0IG5vZGUgZnJvbSBhcHAuc3RhdGVbbm9kZS5ub2RlSURdXG4gICAgLy8gbG9vcCBub2RlLmxpbmVzIChhcnJheSBvZiBvYmplY3RzKVxuICAgIC8vIGVhY2ggbGluZTogZ2V0IGFwcC5zdGF0ZS5jb25uZWN0aW9uc1tsaW5lSURdXG4gICAgLy8gdXBkYXRlIG1hdGNoZWQgbGluZSBhY2NvcmRpbmcgdG8gbm9kZS5saW5lc1t4XS5wb2ludCAoc3RhcnR8ZW5kKVxuXG4gICAgcmV0dXJuIGFwcDtcbn1cblxuZnVuY3Rpb24gcmVzaXplQ2FudmFzKCkge1xuICAgIGNhbnZhcy5zZXRIZWlnaHQod2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBjYW52YXMuc2V0V2lkdGgod2luZG93LmlubmVyV2lkdGgpO1xuICAgIGNhbnZhcy5yZW5kZXJBbGwoKTtcbn1cbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhbnZhc1NldHVwKGFwcCkge1xuLy8gICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhZ2UnKTtcbi8vICAgICBhcHAucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoY2FudmFzKTtcblxuLy8gICAgIHJldHVybiBhcHA7XG4vLyB9XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vL1xuLy8vICAgMC0tLS0tLS1PICAgICAgICAgMCA9IHN0YXJ0ICAgTyA9IGVuZFxuLy8vIFxuLy8vIGxpbmUgcHJvcGVydGllczogeDEsIHkxLCBzdGFydE5vZGVJRCwgeDIsIHkyLCBlbmROb2RlSUQsIGxpbmVJRCAoY29sb3IsIHN0cm9rZSwgZXRjLi4uKVxuLy8vIFdoZW4gc29tZSBub2RlIHVwZGF0ZXMgcG9zaXRpb24sIHVzZSBsaW5lSUQgKHN0b3JlZCBvbiBub2RlPylcbi8vLyB0byBmZXRjaCBsaW5lIGZyb20gc3RvcmUgKGJ5IGxpbmVJRCkgYW5kIHVwZGF0ZSBpdCdzIHgveVxuLy8vXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLyBBTFQgLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vXG4vLy8gY2lyY2xlIGNyZWF0ZWRcbi8vL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9jYW52YXMtc2V0dXAuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgZ3VpZCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5jb25zdCBub2RlUmFkaXVzID0gNTA7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNwYXduTm9kZShhcHAsIGV2ZW50KSB7XG4gICAgbGV0IHsgcGFnZVgsIHBhZ2VZIH0gPSBldmVudC5lLnRvdWNoZXMgPyBldmVudC5lLnRvdWNoZXNbMF0gOiBldmVudC5lO1xuICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSAtMjA7XG4gICAgICAgIGxldCBub2RlSUQgPSBndWlkKCk7XG4gICAgICAgIGxldCBjZW50ZXJlZCA9IHtcbiAgICAgICAgICAgIHg6IChwYWdlWCAtIG5vZGVSYWRpdXMpLFxuICAgICAgICAgICAgeTogKHBhZ2VZIC0gbm9kZVJhZGl1cyksXG4gICAgICAgIH07XG4gICAgICAgIGFkZENpcmNsZSh7XG4gICAgICAgICAgICB4OiBjZW50ZXJlZC54LFxuICAgICAgICAgICAgeTogY2VudGVyZWQueSxcbiAgICAgICAgICAgIGNvbG9yOiBhcHAuc3RhdGUuY3VycmVudFVzZXIuY29sb3IsXG4gICAgICAgICAgICBjYW52YXM6IGFwcC5jYW52YXMsXG4gICAgICAgICAgICBub2RlSURcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjdXJyZW50VXNlciA9IGFwcC5zdGF0ZS5jdXJyZW50VXNlcjtcbiAgICAgICAgLy8gYXBwLnN0YXRlLm5vZGVzLnB1c2goe1xuICAgICAgICAvLyAgICAgY29sb3I6IGN1cnJlbnRVc2VyLmNvbG9yLFxuICAgICAgICAvLyAgICAgY29vcmRzOiBjZW50ZXJlZCxcbiAgICAgICAgLy8gICAgIHVzZXJJRDogY3VycmVudFVzZXIudXNlcklELFxuICAgICAgICAvLyAgICAgbm9kZUlEXG4gICAgICAgIC8vIH0pO1xuICAgICAgICBhcHAuc3RhdGUubm9kZXNbbm9kZUlEXSA9IHtcbiAgICAgICAgICAgIGNvbG9yOiBjdXJyZW50VXNlci5jb2xvcixcbiAgICAgICAgICAgIGNvb3JkczogY2VudGVyZWQsXG4gICAgICAgICAgICB1c2VySUQ6IGN1cnJlbnRVc2VyLnVzZXJJRCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNlbnRlcmVkLngsXG4gICAgICAgICAgICB5OiBjZW50ZXJlZC55LFxuICAgICAgICAgICAgbm9kZUlEXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRDaXJjbGUoe3gsIHksIGNvbG9yLCBjYW52YXMsIG5vZGVJRH0pIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIngsIHksIGNvbG9yLCBjYW52YXNcIiwgeCwgeSwgY29sb3IsIGNhbnZhcyk7XG4gICAgbGV0IGNpcmNsZSA9IG5ldyBmYWJyaWMuQ2lyY2xlKHtcbiAgICAgICAgbGVmdDogeCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICByYWRpdXM6IG5vZGVSYWRpdXMsXG4gICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICBoYXNDb250cm9sczogZmFsc2UsXG4gICAgICAgIGlkOiBub2RlSURcbiAgICB9KTtcbiAgICBjYW52YXMuYWRkKGNpcmNsZSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0cy9jbGllbnQvc3Bhd24tbm9kZS5qcyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFscyBNYXRoICovXG5cbmltcG9ydCB7IGNvb3Jkc0FyZU51bGwgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuY29uc3QgZW1wdHlDb29yZHMgPSAoKSA9PiB7IHJldHVybiB7IHg6bnVsbCwgeTpudWxsLCBub2RlSUQ6JycgfTsgfTtcbmxldCBjbG9zZXN0ID0gZW1wdHlDb29yZHMoKTtcbmxldCBuZXh0Q2xvc2VzdCA9IGVtcHR5Q29vcmRzKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5lYXJlc3ROb2RlcyB7XG4gICAgY29uc3RydWN0b3IoYXBwKSB7XG4gICAgICAgIC8vIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLm5vZGVzID0gYXBwLnN0YXRlLm5vZGVzO1xuICAgIH1cblxuICAgIC8vIG9ubHkgdXNpbmcgZ2V0dGVyL3NldHRlciBwYXR0ZXJuIGluIGNhc2UgSSBwYXNzIG9iamVjdCB0byBzZXQgY29vcmRzIGFuZCBpdCBoYXMgbW9yZSB0aGFuIHgveVxuICAgIGdldCBjbG9zZXN0KCkge1xuICAgICAgICByZXR1cm4gY2xvc2VzdDtcbiAgICB9XG4gICAgc2V0IGNsb3Nlc3Qoe3gsIHksIG5vZGVJRH0pIHtcbiAgICAgICAgY2xvc2VzdC54ID0geDtcbiAgICAgICAgY2xvc2VzdC55ID0geTtcbiAgICAgICAgY2xvc2VzdC5ub2RlSUQgPSBub2RlSUQ7XG4gICAgfVxuICAgIGdldCBuZXh0Q2xvc2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIG5leHRDbG9zZXN0O1xuICAgIH1cbiAgICBzZXQgbmV4dENsb3Nlc3Qoe3gsIHksIG5vZGVJRH0pIHtcbiAgICAgICAgbmV4dENsb3Nlc3QueCA9IHg7XG4gICAgICAgIG5leHRDbG9zZXN0LnkgPSB5O1xuICAgICAgICBuZXh0Q2xvc2VzdC5ub2RlSUQgPSBub2RlSUQ7XG4gICAgfVxuXG4gICAgZmluZENsb3Nlc3RUbyh7eCwgeSwgbm9kZUlEfSkge1xuICAgICAgICBsZXQgY29vcmRzID0geyB4LCB5IH07XG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcblxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgbG9vcEFjdGlvbih0aGlzLm5vZGVzW2tleV0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzLm5vZGVzLmZvckVhY2godG1wTm9kZSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIGxvb3BBY3Rpb24odG1wTm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGVJRCA9PT0gdG1wTm9kZS5ub2RlSUQpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGNvb3Jkc0FyZU51bGwoc2VsZi5jbG9zZXN0KSkge1xuICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VzdCA9IE9iamVjdC5hc3NpZ24oeyBub2RlSUQ6IHRtcE5vZGUubm9kZUlEIH0sIHRtcE5vZGUuY29vcmRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UoY29vcmRzLCBzZWxmLmNsb3Nlc3QpID4gZGlzdGFuY2UoY29vcmRzLCB0bXBOb2RlLmNvb3JkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5uZXh0Q2xvc2VzdCA9IHNlbGYuY2xvc2VzdDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbG9zZXN0ID0gT2JqZWN0LmFzc2lnbih7IG5vZGVJRDogdG1wTm9kZS5ub2RlSUQgfSwgdG1wTm9kZS5jb29yZHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb29yZHNBcmVOdWxsKHNlbGYubmV4dENsb3Nlc3QpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZShjb29yZHMsIHNlbGYubmV4dENsb3Nlc3QpID4gZGlzdGFuY2UoY29vcmRzLCB0bXBOb2RlLmNvb3JkcykpIHtcblxuICAgICAgICAgICAgICAgIHNlbGYubmV4dENsb3Nlc3QgPSBPYmplY3QuYXNzaWduKHsgbm9kZUlEOiB0bXBOb2RlLm5vZGVJRCB9LCB0bXBOb2RlLmNvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbG9zZXN0OiB0aGlzLmNsb3Nlc3QsXG4gICAgICAgICAgICBuZXh0Q2xvc2VzdDogdGhpcy5uZXh0Q2xvc2VzdCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpc3RhbmNlKHt4OngxLCB5OnkxfSwge3g6eDIsIHk6eTJ9KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgTWF0aC5wb3coKHgxIC0geDIpLCAyKSArIE1hdGgucG93KCh5MSAtIHkyKSwgMilcbiAgICApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NjcmlwdHMvY2xpZW50L2ZpbmQtbmVhcmVzdC1ub2Rlcy5qcyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFscyBjb25zb2xlICovXG5cbmltcG9ydCB7IGNvb3Jkc0FyZU51bGwsIGd1aWQsIGlzQXJyYXkgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLy8gVGhpbmdzIG5lZWRlZCB0byBkcmF3IGxpbmVzXG4vLyAtIGNvbG9yXG4vLyAtIHN0YXJ0IHBvaW50IChjb29yZHMgJiBwYXJlbnQgY2lyY2xlIElEKVxuLy8gLSBlbmQgcG9pbnQgKGNvb3JkcyAmIHBhcmVudCBjaXJjbGUgSUQpXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkcmF3TGluZShhcHAsIGV2ZW50LCBzdGFydE5vZGUsIGVuZE5vZGUpIHsgLy8gVE9ETyByZW1vdmUgZXZlbnQgcGFyYW0/XG4gICAgaWYgKGNvb3Jkc0FyZU51bGwoZW5kTm9kZSkpIHJldHVybjtcblxuICAgIGxldCBsaW5lQ29sb3IgPSAnIzAwMDAwMCc7XG4gICAgbGV0IG9mZnNldCA9IDUwO1xuICAgIGxldCBjb29yZHMgPSBbXG4gICAgICAgIChzdGFydE5vZGUueCArIG9mZnNldCksXG4gICAgICAgIChzdGFydE5vZGUueSArIG9mZnNldCksXG4gICAgICAgIChlbmROb2RlLnggKyBvZmZzZXQpLFxuICAgICAgICAoZW5kTm9kZS55ICsgb2Zmc2V0KSxcbiAgICBdO1xuXG4gICAgbGV0IGxpbmVTdG9yZSA9IHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIHg6IHN0YXJ0Tm9kZS54LFxuICAgICAgICAgICAgeTogc3RhcnROb2RlLnksXG4gICAgICAgICAgICBub2RlSUQ6IHN0YXJ0Tm9kZS5ub2RlSUQsXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgICAgeDogZW5kTm9kZS54LFxuICAgICAgICAgICAgeTogZW5kTm9kZS55LFxuICAgICAgICAgICAgbm9kZUlEOiBlbmROb2RlLm5vZGVJRCxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGxldCBsaW5lID0gYWRkTGluZShjb29yZHMsIGxpbmVDb2xvciwgYXBwLmNhbnZhcyk7XG5cbiAgICB1cGRhdGVTdGF0ZShsaW5lLmxpbmVJRCwgYXBwLnN0YXRlLm5vZGVzW3N0YXJ0Tm9kZS5ub2RlSURdLCBhcHAuc3RhdGUubm9kZXNbZW5kTm9kZS5ub2RlSURdKTtcblxuICAgIHJldHVybiBsaW5lO1xufVxuXG5mdW5jdGlvbiBhZGRMaW5lKGNvb3JkcywgY29sb3IsIGNhbnZhcykge1xuICAgIGxldCBsaW5lID0gbmV3IGZhYnJpYy5MaW5lKGNvb3Jkcywge1xuICAgICAgICBpZDogZ3VpZCgpLFxuICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogNSxcbiAgICAgICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgfSk7XG5cbiAgICBjYW52YXMuYWRkKGxpbmUpO1xuICAgIGNhbnZhcy5zZW5kVG9CYWNrKGxpbmUpO1xuICAgIHJldHVybiBsaW5lO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShsaW5lSUQsIHN0b3JlZFN0YXJ0Tm9kZSwgc3RvcmVkRW5kTm9kZSkge1xuICAgIGlmICghaXNBcnJheShzdG9yZWRTdGFydE5vZGUubGluZXMpKSB7XG4gICAgICAgIHN0b3JlZFN0YXJ0Tm9kZS5saW5lcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXkoc3RvcmVkRW5kTm9kZS5saW5lcykpIHtcbiAgICAgICAgc3RvcmVkRW5kTm9kZS5saW5lcyA9IFtdO1xuICAgIH1cbiAgICBzdG9yZWRTdGFydE5vZGUubGluZXMucHVzaCh7XG4gICAgICAgIGxpbmVJRDogbGluZS5saW5lSUQsXG4gICAgICAgIHBvaW50OiAnc3RhcnQnXG4gICAgfSk7XG4gICAgc3RvcmVkRW5kTm9kZS5saW5lcy5wdXNoKHtcbiAgICAgICAgbGluZUlEOiBsaW5lLmxpbmVJRCxcbiAgICAgICAgcG9pbnQ6ICdlbmQnXG4gICAgfSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0cy9jbGllbnQvZHJhdy1saW5lLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGd1aWQsIHJhbmRvbUhleCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRVc2VyKGFwcCkge1xuICAgIGxldCB1c2VySUQgPSBndWlkKCk7XG4gICAgbGV0IGNvbG9yID0gcmFuZG9tSGV4KCk7XG4gICAgYXBwLnN0YXRlLnVzZXJzW3VzZXJJRF0gPSB7IGNvbG9yIH07XG5cbiAgICBhcHAuc3RhdGUuY3VycmVudFVzZXIgPSB7XG4gICAgICAgIHVzZXJJRCwgY29sb3JcbiAgICB9O1xuXG4gICAgcmV0dXJuIGFwcDtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0cy9jbGllbnQvYWRkLXVzZXIuanMiXSwic291cmNlUm9vdCI6IiJ9