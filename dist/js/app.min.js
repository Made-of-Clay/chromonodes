/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals console */

// import './rAF-polyfill.js';

var _state = __webpack_require__(1);

var _state2 = _interopRequireDefault(_state);

var _canvasSetup = __webpack_require__(2);

var _canvasSetup2 = _interopRequireDefault(_canvasSetup);

var _addUser = __webpack_require__(5);

var _addUser2 = _interopRequireDefault(_addUser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// let renderer;
var app = {
    state: _state2.default

    // draw() {
    // let time;
    // let controls = document.getElementById('controls');
    // time = new Date();
    // controls.innerText = `${time.getHours()}:${time.getMinutes()}:${time.getSeconds()}.${time.getMilliseconds()}`;

    // // this.renderer.clear();
    // if (this.state.nodes.length) {
    //     this.state.nodes.forEach(node => {
    //         // check if node.userID matches userID
    //         // if so, use coords for circle; get node color from state.user[userID].color
    //     })
    // }
    // },
};

Promise.resolve(app).then(_addUser2.default).then(_canvasSetup2.default)
// .then(() => animate())
.then(function () {
    return console.log("state", _state2.default);
}).catch(function (thrown) {
    return console.error('%cAn error occurred:', 'font-weight:bold', thrown);
});

// function animate() {
//     app.draw();
//     requestAnimationFrame(animate);
// }
function output(str) {
    document.getElementById('output').innerHTML += '<br>' + str;
}
window.getState = function () {
    return console.log('app.state', app.state);
};
/*
TODO: get touch-add working
-- create node using user's color
-- save node info to nodes array
TODO: share state over websockets
TODO: update state object when socket info comes in
 */

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// The Truth!

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    nodes: [],
    connections: [],
    users: {},
    currentUser: {
        userID: '',
        color: ''
    }
};

/*
e.g. 
{
    nodes: [{
        userID: 'guid',
        coords: [{ x:0, y:0 }],
        nodeID: 'guid'
    }],
    connections: [{
        e1: { x:0, y:0 },
        e2: { x:0, y:0 },
    }],
    users: {
        guid: {
            color: ''
        }
    }
}
 */

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*  */

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = canvasSetup;

var _spawnNode = __webpack_require__(3);

var _spawnNode2 = _interopRequireDefault(_spawnNode);

var _findNearestNodes = __webpack_require__(4);

var _findNearestNodes2 = _interopRequireDefault(_findNearestNodes);

var _drawLine = __webpack_require__(7);

var _drawLine2 = _interopRequireDefault(_drawLine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var canvas = void 0;function canvasSetup(app) {
    var nearestNodes = new _findNearestNodes2.default(app);
    canvas = new fabric.Canvas('stage');

    fabric.Group.prototype.hasControls = false;
    canvas.selection = false;

    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas();
    app.resizeCanvas = resizeCanvas;
    app.canvas = canvas;

    canvas.on({
        'mouse:down': function mouseDown(event) {
            var node = (0, _spawnNode2.default)(app, event);
            if (node) {
                var nn = nearestNodes.findClosestTo(node);
                console.log('closest', nn.closest, 'nextClosest', nn.nextClosest);
                // draw lines
                // draw line from node.xy to closest.xy
                // draw line from node.xy to nextClosest.xy
                // save drawn lines to connections in state
                (0, _drawLine2.default)(app, event, node, nn.closest);
                (0, _drawLine2.default)(app, event, node, nn.nextClosest);
            }
        }
    });

    return app;
}

function resizeCanvas() {
    canvas.setHeight(window.innerHeight);
    canvas.setWidth(window.innerWidth);
    canvas.renderAll();
}
// export default function canvasSetup(app) {
//     let canvas = document.getElementById('stage');
//     app.renderer = new Renderer(canvas);

//     return app;
// }

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = spawnNode;

var _utils = __webpack_require__(6);

var nodeRadius = 50;

function spawnNode(app, event) {
    var _ref = event.e.touches ? event.e.touches[0] : event.e,
        pageX = _ref.pageX,
        pageY = _ref.pageY;

    if (!event.target) {
        var offset = -20;
        var nodeID = (0, _utils.guid)();
        var centered = {
            x: pageX - nodeRadius,
            y: pageY - nodeRadius
        };
        addCircle({
            x: centered.x,
            y: centered.y,
            color: app.state.currentUser.color,
            canvas: app.canvas,
            nodeID: nodeID
        });
        var currentUser = app.state.currentUser;
        app.state.nodes.push({
            color: currentUser.color,
            coords: centered,
            userID: currentUser.userID,
            nodeID: nodeID
        });
        return { centered: centered, nodeID: nodeID };
    }
}

function addCircle(_ref2) {
    var x = _ref2.x,
        y = _ref2.y,
        color = _ref2.color,
        canvas = _ref2.canvas,
        nodeID = _ref2.nodeID;

    // console.log("x, y, color, canvas", x, y, color, canvas);
    var circle = new fabric.Circle({
        left: x,
        top: y,
        radius: nodeRadius,
        fill: color,
        hasControls: false,
        id: nodeID
    });
    canvas.add(circle);
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals Math */

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _utils = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var emptyCoords = function emptyCoords() {
    return { x: null, y: null };
};
var closest = emptyCoords();
var nextClosest = emptyCoords();

var NearestNodes = function () {
    function NearestNodes(app) {
        _classCallCheck(this, NearestNodes);

        // this.app = app;
        this.nodes = app.state.nodes;
    }

    // only using getter/setter pattern in case I pass object to set coords and it has more than x/y


    _createClass(NearestNodes, [{
        key: "findClosestTo",
        value: function findClosestTo(_ref) {
            var _this = this;

            var coords = _ref.centered,
                nodeID = _ref.nodeID;

            this.nodes.forEach(function (tmpNode) {
                if (nodeID === tmpNode.nodeID) return;

                if ((0, _utils.coordsAreNull)(_this.closest)) {
                    _this.closest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                } else if (distance(coords, _this.closest) > distance(coords, tmpNode.coords)) {
                    _this.nextClosest = _this.closest;
                    _this.closest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                } else if ((0, _utils.coordsAreNull)(_this.nextClosest) || distance(coords, _this.nextClosest) > distance(coords, tmpNode.coords)) {

                    _this.nextClosest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                }
            });
            return {
                closest: this.closest,
                nextClosest: this.nextClosest
            };
        }
    }, {
        key: "closest",
        get: function get() {
            return closest;
        },
        set: function set(_ref2) {
            var x = _ref2.x,
                y = _ref2.y;

            closest.x = x;
            closest.y = y;
        }
    }, {
        key: "nextClosest",
        get: function get() {
            return nextClosest;
        },
        set: function set(_ref3) {
            var x = _ref3.x,
                y = _ref3.y;

            nextClosest.x = x;
            nextClosest.y = y;
        }
    }]);

    return NearestNodes;
}();

exports.default = NearestNodes;


function distance(_ref4, _ref5) {
    var x1 = _ref4.x,
        y1 = _ref4.y;
    var x2 = _ref5.x,
        y2 = _ref5.y;

    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addUser;

var _utils = __webpack_require__(6);

function addUser(app) {
    var userID = (0, _utils.guid)();
    var color = (0, _utils.randomHex)();
    app.state.users[userID] = { color: color };

    app.state.currentUser = {
        userID: userID, color: color
    };

    return app;
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.guid = guid;
exports.randomHex = randomHex;
exports.getDistance = getDistance;
exports.isNull = isNull;
exports.coordsAreNull = coordsAreNull;
function guid() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    // return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    return "" + s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
}

function randomHex() {
    return '#' + Math.floor(Math.random() * 16777215).toString(16);
}

function getDistance(coords1, coords2) {
    return Math.sqrt(Math.pow(coords1.x - coords2.x, 2) + Math.pow(coords1.y - coords2.y, 2));
}

function isNull(value) {
    return value === null;
}

function coordsAreNull(obj) {
    return isNull(obj.x) && isNull(obj.y);
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals console */

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = drawLine;

var _utils = __webpack_require__(6);

function drawLine(app, event, node1, node2) {
    console.log('drawLine args', arguments);
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOWUwMTU2ODBiNDU3MmQyMDYyYjciLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L3N0YXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NsaWVudC9jYW52YXMtc2V0dXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L3NwYXduLW5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L2ZpbmQtbmVhcmVzdC1ub2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jbGllbnQvYWRkLXVzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NsaWVudC9kcmF3LWxpbmUuanMiXSwibmFtZXMiOlsiYXBwIiwic3RhdGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJjb25zb2xlIiwibG9nIiwiY2F0Y2giLCJlcnJvciIsInRocm93biIsIm91dHB1dCIsInN0ciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJpbm5lckhUTUwiLCJ3aW5kb3ciLCJnZXRTdGF0ZSIsIm5vZGVzIiwiY29ubmVjdGlvbnMiLCJ1c2VycyIsImN1cnJlbnRVc2VyIiwidXNlcklEIiwiY29sb3IiLCJjYW52YXNTZXR1cCIsImNhbnZhcyIsIm5lYXJlc3ROb2RlcyIsImZhYnJpYyIsIkNhbnZhcyIsIkdyb3VwIiwicHJvdG90eXBlIiwiaGFzQ29udHJvbHMiLCJzZWxlY3Rpb24iLCJhZGRFdmVudExpc3RlbmVyIiwicmVzaXplQ2FudmFzIiwib24iLCJub2RlIiwiZXZlbnQiLCJubiIsImZpbmRDbG9zZXN0VG8iLCJjbG9zZXN0IiwibmV4dENsb3Nlc3QiLCJzZXRIZWlnaHQiLCJpbm5lckhlaWdodCIsInNldFdpZHRoIiwiaW5uZXJXaWR0aCIsInJlbmRlckFsbCIsInNwYXduTm9kZSIsIm5vZGVSYWRpdXMiLCJlIiwidG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJ0YXJnZXQiLCJvZmZzZXQiLCJub2RlSUQiLCJjZW50ZXJlZCIsIngiLCJ5IiwiYWRkQ2lyY2xlIiwicHVzaCIsImNvb3JkcyIsImNpcmNsZSIsIkNpcmNsZSIsImxlZnQiLCJ0b3AiLCJyYWRpdXMiLCJmaWxsIiwiaWQiLCJhZGQiLCJlbXB0eUNvb3JkcyIsIk5lYXJlc3ROb2RlcyIsImZvckVhY2giLCJ0bXBOb2RlIiwiT2JqZWN0IiwiYXNzaWduIiwiZGlzdGFuY2UiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIk1hdGgiLCJzcXJ0IiwicG93IiwiYWRkVXNlciIsImd1aWQiLCJyYW5kb21IZXgiLCJnZXREaXN0YW5jZSIsImlzTnVsbCIsImNvb3Jkc0FyZU51bGwiLCJzNCIsImZsb29yIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJjb29yZHMxIiwiY29vcmRzMiIsInZhbHVlIiwib2JqIiwiZHJhd0xpbmUiLCJub2RlMSIsIm5vZGUyIiwiYXJndW1lbnRzIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDN0RBO0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztB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RUFBNUMsQ0FBYjtBQUNIOztBQUVNLFNBQVNOLFdBQVQsQ0FBcUJRLE9BQXJCLEVBQThCQyxPQUE5QixFQUF1QztBQUMxQyxXQUFPZixLQUFLQyxJQUFMLENBQVVELEtBQUtFLEdBQUwsQ0FBVVksUUFBUXRDLENBQVIsR0FBWXVDLFFBQVF2QyxDQUE5QixFQUFrQyxDQUFsQyxJQUF1Q3dCLEtBQUtFLEdBQUwsQ0FBVVksUUFBUXJDLENBQVIsR0FBWXNDLFFBQVF0QyxDQUE5QixFQUFrQyxDQUFsQyxDQUFqRCxDQUFQO0FBQ0g7O0FBRU0sU0FBUzhCLE1BQVQsQ0FBZ0JTLEtBQWhCLEVBQXVCO0FBQzFCLFdBQU9BLFVBQVUsSUFBakI7QUFDSDs7QUFFTSxTQUFTUixhQUFULENBQXVCUyxHQUF2QixFQUE0QjtBQUMvQixXQUFPVixPQUFPVSxJQUFJekMsQ0FBWCxLQUFpQitCLE9BQU9VLElBQUl4QyxDQUFYLENBQXhCO0FBQ0gsQzs7Ozs7OztBQzFCRDtBQUNBOzs7OztrQkFJd0J5QyxROztBQUZ4Qjs7QUFFZSxTQUFTQSxRQUFULENBQWtCbEcsR0FBbEIsRUFBdUJvQyxLQUF2QixFQUE4QitELEtBQTlCLEVBQXFDQyxLQUFyQyxFQUE0QztBQUN2RC9GLFlBQVFDLEdBQVIsQ0FBWSxlQUFaLEVBQTZCK0YsU0FBN0I7QUFDSCxDIiwiZmlsZSI6ImFwcC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA5ZTAxNTY4MGI0NTcyZDIwNjJiNyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFscyBjb25zb2xlICovXG5cbi8vIGltcG9ydCAnLi9yQUYtcG9seWZpbGwuanMnO1xuaW1wb3J0IHN0YXRlIGZyb20gJy4vc3RhdGUuanMnO1xuaW1wb3J0IGNhbnZhc1NldHVwIGZyb20gJy4vY2FudmFzLXNldHVwLmpzJztcbmltcG9ydCBhZGRVc2VyIGZyb20gJy4vYWRkLXVzZXIuanMnO1xuXG4vLyBsZXQgcmVuZGVyZXI7XG5sZXQgYXBwID0ge1xuICAgIHN0YXRlLFxuXG4gICAgLy8gZHJhdygpIHtcbiAgICAgICAgLy8gbGV0IHRpbWU7XG4gICAgICAgIC8vIGxldCBjb250cm9scyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250cm9scycpO1xuICAgICAgICAvLyB0aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgLy8gY29udHJvbHMuaW5uZXJUZXh0ID0gYCR7dGltZS5nZXRIb3VycygpfToke3RpbWUuZ2V0TWludXRlcygpfToke3RpbWUuZ2V0U2Vjb25kcygpfS4ke3RpbWUuZ2V0TWlsbGlzZWNvbmRzKCl9YDtcbiAgICAgICAgXG4gICAgICAgIC8vIC8vIHRoaXMucmVuZGVyZXIuY2xlYXIoKTtcbiAgICAgICAgLy8gaWYgKHRoaXMuc3RhdGUubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vICAgICB0aGlzLnN0YXRlLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgLy8gY2hlY2sgaWYgbm9kZS51c2VySUQgbWF0Y2hlcyB1c2VySURcbiAgICAgICAgLy8gICAgICAgICAvLyBpZiBzbywgdXNlIGNvb3JkcyBmb3IgY2lyY2xlOyBnZXQgbm9kZSBjb2xvciBmcm9tIHN0YXRlLnVzZXJbdXNlcklEXS5jb2xvclxuICAgICAgICAvLyAgICAgfSlcbiAgICAgICAgLy8gfVxuICAgIC8vIH0sXG59O1xuXG5Qcm9taXNlLnJlc29sdmUoYXBwKVxuICAgIC50aGVuKGFkZFVzZXIpXG4gICAgLnRoZW4oY2FudmFzU2V0dXApXG4gICAgLy8gLnRoZW4oKCkgPT4gYW5pbWF0ZSgpKVxuICAgIC50aGVuKCgpID0+IGNvbnNvbGUubG9nKFwic3RhdGVcIiwgc3RhdGUpKVxuICAgIC5jYXRjaCh0aHJvd24gPT4gY29uc29sZS5lcnJvcignJWNBbiBlcnJvciBvY2N1cnJlZDonLCAnZm9udC13ZWlnaHQ6Ym9sZCcsIHRocm93bikpXG47XG5cbi8vIGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4vLyAgICAgYXBwLmRyYXcoKTtcbi8vICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4vLyB9XG5mdW5jdGlvbiBvdXRwdXQoc3RyKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ291dHB1dCcpLmlubmVySFRNTCArPSBgPGJyPiR7c3RyfWA7XG59XG53aW5kb3cuZ2V0U3RhdGUgPSAoKSA9PiBjb25zb2xlLmxvZygnYXBwLnN0YXRlJywgYXBwLnN0YXRlKTtcbi8qXG5UT0RPOiBnZXQgdG91Y2gtYWRkIHdvcmtpbmdcbi0tIGNyZWF0ZSBub2RlIHVzaW5nIHVzZXIncyBjb2xvclxuLS0gc2F2ZSBub2RlIGluZm8gdG8gbm9kZXMgYXJyYXlcblRPRE86IHNoYXJlIHN0YXRlIG92ZXIgd2Vic29ja2V0c1xuVE9ETzogdXBkYXRlIHN0YXRlIG9iamVjdCB3aGVuIHNvY2tldCBpbmZvIGNvbWVzIGluXG4gKi9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9tYWluLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoZSBUcnV0aCFcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBub2RlczogW10sXG4gICAgY29ubmVjdGlvbnM6IFtdLFxuICAgIHVzZXJzOiB7fSxcbiAgICBjdXJyZW50VXNlcjoge1xuICAgICAgICB1c2VySUQ6ICcnLFxuICAgICAgICBjb2xvcjogJydcbiAgICB9XG59O1xuXG4vKlxuZS5nLiBcbntcbiAgICBub2RlczogW3tcbiAgICAgICAgdXNlcklEOiAnZ3VpZCcsXG4gICAgICAgIGNvb3JkczogW3sgeDowLCB5OjAgfV0sXG4gICAgICAgIG5vZGVJRDogJ2d1aWQnXG4gICAgfV0sXG4gICAgY29ubmVjdGlvbnM6IFt7XG4gICAgICAgIGUxOiB7IHg6MCwgeTowIH0sXG4gICAgICAgIGUyOiB7IHg6MCwgeTowIH0sXG4gICAgfV0sXG4gICAgdXNlcnM6IHtcbiAgICAgICAgZ3VpZDoge1xuICAgICAgICAgICAgY29sb3I6ICcnXG4gICAgICAgIH1cbiAgICB9XG59XG4gKi9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9zdGF0ZS5qcyIsIlwidXNlIHN0cmljdFwiO1xuLyogICovXG5pbXBvcnQgc3Bhd25Ob2RlIGZyb20gJy4vc3Bhd24tbm9kZS5qcyc7XG5pbXBvcnQgTmVhcmVzdE5vZGVzIGZyb20gJy4vZmluZC1uZWFyZXN0LW5vZGVzLmpzJztcbmltcG9ydCBkcmF3TGluZSBmcm9tICcuL2RyYXctbGluZS5qcyc7XG5cbmxldCBjYW52YXM7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhbnZhc1NldHVwKGFwcCkge1xuICAgIGNvbnN0IG5lYXJlc3ROb2RlcyA9IG5ldyBOZWFyZXN0Tm9kZXMoYXBwKTtcbiAgICBjYW52YXMgPSBuZXcgZmFicmljLkNhbnZhcygnc3RhZ2UnKTtcblxuICAgIGZhYnJpYy5Hcm91cC5wcm90b3R5cGUuaGFzQ29udHJvbHMgPSBmYWxzZTtcbiAgICBjYW52YXMuc2VsZWN0aW9uID0gZmFsc2U7XG4gICAgXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUNhbnZhcywgZmFsc2UpO1xuICAgIHJlc2l6ZUNhbnZhcygpO1xuICAgIGFwcC5yZXNpemVDYW52YXMgPSByZXNpemVDYW52YXM7XG4gICAgYXBwLmNhbnZhcyA9IGNhbnZhcztcblxuICAgIGNhbnZhcy5vbih7XG4gICAgICAgICdtb3VzZTpkb3duJzogZXZlbnQgPT4ge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBzcGF3bk5vZGUoYXBwLCBldmVudCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGxldCBubiA9IG5lYXJlc3ROb2Rlcy5maW5kQ2xvc2VzdFRvKG5vZGUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgICAnY2xvc2VzdCcsIG5uLmNsb3Nlc3QsXG4gICAgICAgICAgICAgICAgICAgICduZXh0Q2xvc2VzdCcsIG5uLm5leHRDbG9zZXN0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBkcmF3IGxpbmVzXG4gICAgICAgICAgICAgICAgLy8gZHJhdyBsaW5lIGZyb20gbm9kZS54eSB0byBjbG9zZXN0Lnh5XG4gICAgICAgICAgICAgICAgLy8gZHJhdyBsaW5lIGZyb20gbm9kZS54eSB0byBuZXh0Q2xvc2VzdC54eVxuICAgICAgICAgICAgICAgIC8vIHNhdmUgZHJhd24gbGluZXMgdG8gY29ubmVjdGlvbnMgaW4gc3RhdGVcbiAgICAgICAgICAgICAgICBkcmF3TGluZShhcHAsIGV2ZW50LCBub2RlLCBubi5jbG9zZXN0KTtcbiAgICAgICAgICAgICAgICBkcmF3TGluZShhcHAsIGV2ZW50LCBub2RlLCBubi5uZXh0Q2xvc2VzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhcHA7XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZUNhbnZhcygpIHtcbiAgICBjYW52YXMuc2V0SGVpZ2h0KHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgY2FudmFzLnNldFdpZHRoKHdpbmRvdy5pbm5lcldpZHRoKTtcbiAgICBjYW52YXMucmVuZGVyQWxsKCk7XG59XG4vLyBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYW52YXNTZXR1cChhcHApIHtcbi8vICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YWdlJyk7XG4vLyAgICAgYXBwLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKGNhbnZhcyk7XG5cbi8vICAgICByZXR1cm4gYXBwO1xuLy8gfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NjcmlwdHMvY2xpZW50L2NhbnZhcy1zZXR1cC5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5pbXBvcnQgeyBndWlkIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmNvbnN0IG5vZGVSYWRpdXMgPSA1MDtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3Bhd25Ob2RlKGFwcCwgZXZlbnQpIHtcbiAgICBsZXQgeyBwYWdlWCwgcGFnZVkgfSA9IGV2ZW50LmUudG91Y2hlcyA/IGV2ZW50LmUudG91Y2hlc1swXSA6IGV2ZW50LmU7XG4gICAgaWYgKCFldmVudC50YXJnZXQpIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IC0yMDtcbiAgICAgICAgbGV0IG5vZGVJRCA9IGd1aWQoKTtcbiAgICAgICAgbGV0IGNlbnRlcmVkID0ge1xuICAgICAgICAgICAgeDogKHBhZ2VYIC0gbm9kZVJhZGl1cyksXG4gICAgICAgICAgICB5OiAocGFnZVkgLSBub2RlUmFkaXVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgYWRkQ2lyY2xlKHtcbiAgICAgICAgICAgIHg6IGNlbnRlcmVkLngsXG4gICAgICAgICAgICB5OiBjZW50ZXJlZC55LFxuICAgICAgICAgICAgY29sb3I6IGFwcC5zdGF0ZS5jdXJyZW50VXNlci5jb2xvcixcbiAgICAgICAgICAgIGNhbnZhczogYXBwLmNhbnZhcyxcbiAgICAgICAgICAgIG5vZGVJRFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGN1cnJlbnRVc2VyID0gYXBwLnN0YXRlLmN1cnJlbnRVc2VyO1xuICAgICAgICBhcHAuc3RhdGUubm9kZXMucHVzaCh7XG4gICAgICAgICAgICBjb2xvcjogY3VycmVudFVzZXIuY29sb3IsXG4gICAgICAgICAgICBjb29yZHM6IGNlbnRlcmVkLFxuICAgICAgICAgICAgdXNlcklEOiBjdXJyZW50VXNlci51c2VySUQsXG4gICAgICAgICAgICBub2RlSURcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7IGNlbnRlcmVkLCBub2RlSUQgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZENpcmNsZSh7eCwgeSwgY29sb3IsIGNhbnZhcywgbm9kZUlEfSkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwieCwgeSwgY29sb3IsIGNhbnZhc1wiLCB4LCB5LCBjb2xvciwgY2FudmFzKTtcbiAgICBsZXQgY2lyY2xlID0gbmV3IGZhYnJpYy5DaXJjbGUoe1xuICAgICAgICBsZWZ0OiB4LFxuICAgICAgICB0b3A6IHksXG4gICAgICAgIHJhZGl1czogbm9kZVJhZGl1cyxcbiAgICAgICAgZmlsbDogY29sb3IsXG4gICAgICAgIGhhc0NvbnRyb2xzOiBmYWxzZSxcbiAgICAgICAgaWQ6IG5vZGVJRFxuICAgIH0pO1xuICAgIGNhbnZhcy5hZGQoY2lyY2xlKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9zcGF3bi1ub2RlLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBnbG9iYWxzIE1hdGggKi9cblxuaW1wb3J0IHsgY29vcmRzQXJlTnVsbCB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG5jb25zdCBlbXB0eUNvb3JkcyA9ICgpID0+IHsgcmV0dXJuIHsgeDpudWxsLCB5Om51bGwgfTsgfTtcbmxldCBjbG9zZXN0ID0gZW1wdHlDb29yZHMoKTtcbmxldCBuZXh0Q2xvc2VzdCA9IGVtcHR5Q29vcmRzKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5lYXJlc3ROb2RlcyB7XG4gICAgY29uc3RydWN0b3IoYXBwKSB7XG4gICAgICAgIC8vIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLm5vZGVzID0gYXBwLnN0YXRlLm5vZGVzO1xuICAgIH1cblxuICAgIC8vIG9ubHkgdXNpbmcgZ2V0dGVyL3NldHRlciBwYXR0ZXJuIGluIGNhc2UgSSBwYXNzIG9iamVjdCB0byBzZXQgY29vcmRzIGFuZCBpdCBoYXMgbW9yZSB0aGFuIHgveVxuICAgIGdldCBjbG9zZXN0KCkge1xuICAgICAgICByZXR1cm4gY2xvc2VzdDtcbiAgICB9XG4gICAgc2V0IGNsb3Nlc3Qoe3gsIHl9KSB7XG4gICAgICAgIGNsb3Nlc3QueCA9IHg7XG4gICAgICAgIGNsb3Nlc3QueSA9IHk7XG4gICAgfVxuICAgIGdldCBuZXh0Q2xvc2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIG5leHRDbG9zZXN0O1xuICAgIH1cbiAgICBzZXQgbmV4dENsb3Nlc3Qoe3gsIHl9KSB7XG4gICAgICAgIG5leHRDbG9zZXN0LnggPSB4O1xuICAgICAgICBuZXh0Q2xvc2VzdC55ID0geTtcbiAgICB9XG5cbiAgICBmaW5kQ2xvc2VzdFRvKHtjZW50ZXJlZDpjb29yZHMsIG5vZGVJRH0pIHtcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHRtcE5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGVJRCA9PT0gdG1wTm9kZS5ub2RlSUQpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGNvb3Jkc0FyZU51bGwodGhpcy5jbG9zZXN0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VzdCA9IE9iamVjdC5hc3NpZ24oeyBub2RlSUQ6IHRtcE5vZGUubm9kZUlEIH0sIHRtcE5vZGUuY29vcmRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UoY29vcmRzLCB0aGlzLmNsb3Nlc3QpID4gZGlzdGFuY2UoY29vcmRzLCB0bXBOb2RlLmNvb3JkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2xvc2VzdCA9IHRoaXMuY2xvc2VzdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZXN0ID0gT2JqZWN0LmFzc2lnbih7IG5vZGVJRDogdG1wTm9kZS5ub2RlSUQgfSwgdG1wTm9kZS5jb29yZHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb29yZHNBcmVOdWxsKHRoaXMubmV4dENsb3Nlc3QpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZShjb29yZHMsIHRoaXMubmV4dENsb3Nlc3QpID4gZGlzdGFuY2UoY29vcmRzLCB0bXBOb2RlLmNvb3JkcykpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubmV4dENsb3Nlc3QgPSBPYmplY3QuYXNzaWduKHsgbm9kZUlEOiB0bXBOb2RlLm5vZGVJRCB9LCB0bXBOb2RlLmNvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xvc2VzdDogdGhpcy5jbG9zZXN0LFxuICAgICAgICAgICAgbmV4dENsb3Nlc3Q6IHRoaXMubmV4dENsb3Nlc3QsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkaXN0YW5jZSh7eDp4MSwgeTp5MX0sIHt4OngyLCB5OnkyfSkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGgucG93KCh4MSAtIHgyKSwgMikgKyBNYXRoLnBvdygoeTEgLSB5MiksIDIpXG4gICAgKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9maW5kLW5lYXJlc3Qtbm9kZXMuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgZ3VpZCwgcmFuZG9tSGV4IH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZFVzZXIoYXBwKSB7XG4gICAgbGV0IHVzZXJJRCA9IGd1aWQoKTtcbiAgICBsZXQgY29sb3IgPSByYW5kb21IZXgoKTtcbiAgICBhcHAuc3RhdGUudXNlcnNbdXNlcklEXSA9IHsgY29sb3IgfTtcblxuICAgIGFwcC5zdGF0ZS5jdXJyZW50VXNlciA9IHtcbiAgICAgICAgdXNlcklELCBjb2xvclxuICAgIH07XG5cbiAgICByZXR1cm4gYXBwO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9hZGQtdXNlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBmdW5jdGlvbiBzNCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gICAgcmV0dXJuIGAke3M0KCl9JHtzNCgpfS0ke3M0KCl9LSR7czQoKX0tJHtzNCgpfS0ke3M0KCl9JHtzNCgpfSR7czQoKX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tSGV4KCkge1xuICAgIHJldHVybiAnIycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTY3NzcyMTUpLnRvU3RyaW5nKDE2KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKGNvb3JkczEsIGNvb3JkczIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KChjb29yZHMxLnggLSBjb29yZHMyLngpLCAyKSArIE1hdGgucG93KChjb29yZHMxLnkgLSBjb29yZHMyLnkpLCAyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb29yZHNBcmVOdWxsKG9iaikge1xuICAgIHJldHVybiBpc051bGwob2JqLngpICYmIGlzTnVsbChvYmoueSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0cy9jbGllbnQvdXRpbHMuanMiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbHMgY29uc29sZSAqL1xuXG5pbXBvcnQgeyBjb29yZHNBcmVOdWxsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRyYXdMaW5lKGFwcCwgZXZlbnQsIG5vZGUxLCBub2RlMikge1xuICAgIGNvbnNvbGUubG9nKCdkcmF3TGluZSBhcmdzJywgYXJndW1lbnRzKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9kcmF3LWxpbmUuanMiXSwic291cmNlUm9vdCI6IiJ9