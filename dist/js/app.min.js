/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals console */

// import './rAF-polyfill.js';

var _state = __webpack_require__(1);

var _state2 = _interopRequireDefault(_state);

var _canvasSetup = __webpack_require__(2);

var _canvasSetup2 = _interopRequireDefault(_canvasSetup);

var _addUser = __webpack_require__(5);

var _addUser2 = _interopRequireDefault(_addUser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// let renderer;
var app = {
    state: _state2.default

    // draw() {
    // let time;
    // let controls = document.getElementById('controls');
    // time = new Date();
    // controls.innerText = `${time.getHours()}:${time.getMinutes()}:${time.getSeconds()}.${time.getMilliseconds()}`;

    // // this.renderer.clear();
    // if (this.state.nodes.length) {
    //     this.state.nodes.forEach(node => {
    //         // check if node.userID matches userID
    //         // if so, use coords for circle; get node color from state.user[userID].color
    //     })
    // }
    // },
};

Promise.resolve(app).then(_addUser2.default).then(_canvasSetup2.default)
// .then(() => animate())
.then(function () {
    return console.log("state", _state2.default);
}).catch(function (thrown) {
    return console.error('%cAn error occurred:', 'font-weight:bold', thrown);
});

// function animate() {
//     app.draw();
//     requestAnimationFrame(animate);
// }
function output(str) {
    document.getElementById('output').innerHTML += '<br>' + str;
}
window.getState = function () {
    return console.log('app.state', app.state);
};
/*
TODO: get touch-add working
-- create node using user's color
-- save node info to nodes array
TODO: share state over websockets
TODO: update state object when socket info comes in
 */

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// The Truth!

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    nodes: [],
    connections: [],
    users: {},
    currentUser: {
        userID: '',
        color: ''
    }
};

/*
e.g. 
{
    nodes: [{
        userID: 'guid',
        coords: [{ x:0, y:0 }],
        nodeID: 'guid'
    }],
    connections: [{
        e1: { x:0, y:0 },
        e2: { x:0, y:0 },
    }],
    users: {
        guid: {
            color: ''
        }
    }
}
 */

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*  */

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = canvasSetup;

var _spawnNode = __webpack_require__(3);

var _spawnNode2 = _interopRequireDefault(_spawnNode);

var _findNearestNodes = __webpack_require__(4);

var _findNearestNodes2 = _interopRequireDefault(_findNearestNodes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var canvas = void 0;

function canvasSetup(app) {
    var nearestNodes = new _findNearestNodes2.default(app);
    canvas = new fabric.Canvas('stage');

    fabric.Group.prototype.hasControls = false;
    canvas.selection = false;

    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas();
    app.resizeCanvas = resizeCanvas;
    app.canvas = canvas;

    canvas.on({
        'mouse:down': function mouseDown(event) {
            var node = (0, _spawnNode2.default)(app, event);
            if (node) {
                // find nearest 2 nodes
                // let nearestNodes = findNearestNodes(app, coords);
                // let nearestNodes = nearestNodes.findClosestTo(coords);
                //////////////////////////////////////////////////
                //////////////////////////////////////////////////
                /// need to calc closest 
                //////////////////////////////////////////////////
                //////////////////////////////////////////////////
                var nn = nearestNodes.findClosestTo(node);
                console.log('closest', nn.closest, 'nextClosest', nn.nextClosest);
                // draw lines
            }
        }
    });

    return app;
}

function resizeCanvas() {
    canvas.setHeight(window.innerHeight);
    canvas.setWidth(window.innerWidth);
    canvas.renderAll();
}
// export default function canvasSetup(app) {
//     let canvas = document.getElementById('stage');
//     app.renderer = new Renderer(canvas);

//     return app;
// }

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = spawnNode;

var _utils = __webpack_require__(6);

var nodeRadius = 50;

function spawnNode(app, event) {
    var _ref = event.e.touches ? event.e.touches[0] : event.e,
        pageX = _ref.pageX,
        pageY = _ref.pageY;

    if (!event.target) {
        var offset = -20;
        var nodeID = (0, _utils.guid)();
        var centered = {
            x: pageX - nodeRadius,
            y: pageY - nodeRadius
        };
        addCircle({
            x: centered.x,
            y: centered.y,
            color: app.state.currentUser.color,
            canvas: app.canvas,
            nodeID: nodeID
        });
        var currentUser = app.state.currentUser;
        app.state.nodes.push({
            color: currentUser.color,
            coords: centered,
            userID: currentUser.userID,
            nodeID: nodeID
        });
        return { centered: centered, nodeID: nodeID };
    }
}

function addCircle(_ref2) {
    var x = _ref2.x,
        y = _ref2.y,
        color = _ref2.color,
        canvas = _ref2.canvas,
        nodeID = _ref2.nodeID;

    // console.log("x, y, color, canvas", x, y, color, canvas);
    var circle = new fabric.Circle({
        left: x,
        top: y,
        radius: nodeRadius,
        fill: color,
        hasControls: false,
        id: nodeID
    });
    canvas.add(circle);
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* globals Math */

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var emptyCoords = function emptyCoords() {
    return { x: null, y: null };
};
var closest = emptyCoords();
var nextClosest = emptyCoords();

var NearestNodes = function () {
    function NearestNodes(app) {
        _classCallCheck(this, NearestNodes);

        // this.app = app;
        this.nodes = app.state.nodes;
    }

    // only using getter/setter pattern in case I pass object to set coords and it has more than x/y


    _createClass(NearestNodes, [{
        key: "findClosestTo",
        value: function findClosestTo(_ref) {
            var _this = this;

            var coords = _ref.centered,
                nodeID = _ref.nodeID;

            this.nodes.forEach(function (tmpNode) {
                if (nodeID === tmpNode.nodeID) return;

                if (coordsAreNull(_this.closest)) {
                    _this.closest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                } else if (distance(coords, _this.closest) > distance(coords, tmpNode.coords)) {
                    _this.nextClosest = _this.closest;
                    _this.closest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                } else if (coordsAreNull(_this.nextClosest) || distance(coords, _this.nextClosest) > distance(coords, tmpNode.coords)) {

                    _this.nextClosest = Object.assign({ nodeID: tmpNode.nodeID }, tmpNode.coords);
                }
            });
            return {
                closest: this.closest,
                nextClosest: this.nextClosest
            };
        }
    }, {
        key: "closest",
        get: function get() {
            return closest;
        },
        set: function set(_ref2) {
            var x = _ref2.x,
                y = _ref2.y;

            closest.x = x;
            closest.y = y;
        }
    }, {
        key: "nextClosest",
        get: function get() {
            return nextClosest;
        },
        set: function set(_ref3) {
            var x = _ref3.x,
                y = _ref3.y;

            nextClosest.x = x;
            nextClosest.y = y;
        }
    }]);

    return NearestNodes;
}();

exports.default = NearestNodes;


function isNull(value) {
    return value === null;
}
function coordsAreNull(obj) {
    return isNull(obj.x) && isNull(obj.y);
}
function distance(_ref4, _ref5) {
    var x1 = _ref4.x,
        y1 = _ref4.y;
    var x2 = _ref5.x,
        y2 = _ref5.y;

    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = addUser;

var _utils = __webpack_require__(6);

function addUser(app) {
    var userID = (0, _utils.guid)();
    var color = (0, _utils.randomHex)();
    app.state.users[userID] = { color: color };

    app.state.currentUser = {
        userID: userID, color: color
    };

    return app;
}

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.guid = guid;
exports.randomHex = randomHex;
exports.getDistance = getDistance;
function guid() {
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    // return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    return "" + s4() + s4() + "-" + s4() + "-" + s4() + "-" + s4() + "-" + s4() + s4() + s4();
}

function randomHex() {
    return '#' + Math.floor(Math.random() * 16777215).toString(16);
}

function getDistance(coords1, coords2) {
    return Math.sqrt(Math.pow(coords1.x - coords2.x, 2) + Math.pow(coords1.y - coords2.y, 2));
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjQwZmFlOTg1NDY2Y2I0MmZjZDkiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L3N0YXRlLmpzIiwid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NsaWVudC9jYW52YXMtc2V0dXAuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L3NwYXduLW5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L2ZpbmQtbmVhcmVzdC1ub2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9jbGllbnQvYWRkLXVzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3NjcmlwdHMvY2xpZW50L3V0aWxzLmpzIl0sIm5hbWVzIjpbImFwcCIsInN0YXRlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiY29uc29sZSIsImxvZyIsImNhdGNoIiwiZXJyb3IiLCJ0aHJvd24iLCJvdXRwdXQiLCJzdHIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiaW5uZXJIVE1MIiwid2luZG93IiwiZ2V0U3RhdGUiLCJub2RlcyIsImNvbm5lY3Rpb25zIiwidXNlcnMiLCJjdXJyZW50VXNlciIsInVzZXJJRCIsImNvbG9yIiwiY2FudmFzU2V0dXAiLCJjYW52YXMiLCJuZWFyZXN0Tm9kZXMiLCJmYWJyaWMiLCJDYW52YXMiLCJHcm91cCIsInByb3RvdHlwZSIsImhhc0NvbnRyb2xzIiwic2VsZWN0aW9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlc2l6ZUNhbnZhcyIsIm9uIiwibm9kZSIsImV2ZW50Iiwibm4iLCJmaW5kQ2xvc2VzdFRvIiwiY2xvc2VzdCIsIm5leHRDbG9zZXN0Iiwic2V0SGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJzZXRXaWR0aCIsImlubmVyV2lkdGgiLCJyZW5kZXJBbGwiLCJzcGF3bk5vZGUiLCJub2RlUmFkaXVzIiwiZSIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwidGFyZ2V0Iiwib2Zmc2V0Iiwibm9kZUlEIiwiY2VudGVyZWQiLCJ4IiwieSIsImFkZENpcmNsZSIsInB1c2giLCJjb29yZHMiLCJjaXJjbGUiLCJDaXJjbGUiLCJsZWZ0IiwidG9wIiwicmFkaXVzIiwiZmlsbCIsImlkIiwiYWRkIiwiZW1wdHlDb29yZHMiLCJOZWFyZXN0Tm9kZXMiLCJmb3JFYWNoIiwidG1wTm9kZSIsImNvb3Jkc0FyZU51bGwiLCJPYmplY3QiLCJhc3NpZ24iLCJkaXN0YW5jZSIsImlzTnVsbCIsInZhbHVlIiwib2JqIiwieDEiLCJ5MSIsIngyIiwieTIiLCJNYXRoIiwic3FydCIsInBvdyIsImFkZFVzZXIiLCJndWlkIiwicmFuZG9tSGV4IiwiZ2V0RGlzdGFuY2UiLCJzNCIsImZsb29yIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJjb29yZHMxIiwiY29vcmRzMiJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQzdEQTtBQUNBOztBQUVBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUE7QUFDQSxJQUFJQSxNQUFNO0FBQ05DOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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LEVBQXVDO0FBQzFDLFdBQU9iLEtBQUtDLElBQUwsQ0FBVUQsS0FBS0UsR0FBTCxDQUFVVSxRQUFReEMsQ0FBUixHQUFZeUMsUUFBUXpDLENBQTlCLEVBQWtDLENBQWxDLElBQXVDNEIsS0FBS0UsR0FBTCxDQUFVVSxRQUFRdkMsQ0FBUixHQUFZd0MsUUFBUXhDLENBQTlCLEVBQWtDLENBQWxDLENBQWpELENBQVA7QUFDSCxDIiwiZmlsZSI6ImFwcC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBiNDBmYWU5ODU0NjZjYjQyZmNkOSIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFscyBjb25zb2xlICovXG5cbi8vIGltcG9ydCAnLi9yQUYtcG9seWZpbGwuanMnO1xuaW1wb3J0IHN0YXRlIGZyb20gJy4vc3RhdGUuanMnO1xuaW1wb3J0IGNhbnZhc1NldHVwIGZyb20gJy4vY2FudmFzLXNldHVwLmpzJztcbmltcG9ydCBhZGRVc2VyIGZyb20gJy4vYWRkLXVzZXIuanMnO1xuXG4vLyBsZXQgcmVuZGVyZXI7XG5sZXQgYXBwID0ge1xuICAgIHN0YXRlLFxuXG4gICAgLy8gZHJhdygpIHtcbiAgICAgICAgLy8gbGV0IHRpbWU7XG4gICAgICAgIC8vIGxldCBjb250cm9scyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250cm9scycpO1xuICAgICAgICAvLyB0aW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgLy8gY29udHJvbHMuaW5uZXJUZXh0ID0gYCR7dGltZS5nZXRIb3VycygpfToke3RpbWUuZ2V0TWludXRlcygpfToke3RpbWUuZ2V0U2Vjb25kcygpfS4ke3RpbWUuZ2V0TWlsbGlzZWNvbmRzKCl9YDtcbiAgICAgICAgXG4gICAgICAgIC8vIC8vIHRoaXMucmVuZGVyZXIuY2xlYXIoKTtcbiAgICAgICAgLy8gaWYgKHRoaXMuc3RhdGUubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vICAgICB0aGlzLnN0YXRlLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgLy8gY2hlY2sgaWYgbm9kZS51c2VySUQgbWF0Y2hlcyB1c2VySURcbiAgICAgICAgLy8gICAgICAgICAvLyBpZiBzbywgdXNlIGNvb3JkcyBmb3IgY2lyY2xlOyBnZXQgbm9kZSBjb2xvciBmcm9tIHN0YXRlLnVzZXJbdXNlcklEXS5jb2xvclxuICAgICAgICAvLyAgICAgfSlcbiAgICAgICAgLy8gfVxuICAgIC8vIH0sXG59O1xuXG5Qcm9taXNlLnJlc29sdmUoYXBwKVxuICAgIC50aGVuKGFkZFVzZXIpXG4gICAgLnRoZW4oY2FudmFzU2V0dXApXG4gICAgLy8gLnRoZW4oKCkgPT4gYW5pbWF0ZSgpKVxuICAgIC50aGVuKCgpID0+IGNvbnNvbGUubG9nKFwic3RhdGVcIiwgc3RhdGUpKVxuICAgIC5jYXRjaCh0aHJvd24gPT4gY29uc29sZS5lcnJvcignJWNBbiBlcnJvciBvY2N1cnJlZDonLCAnZm9udC13ZWlnaHQ6Ym9sZCcsIHRocm93bikpXG47XG5cbi8vIGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4vLyAgICAgYXBwLmRyYXcoKTtcbi8vICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4vLyB9XG5mdW5jdGlvbiBvdXRwdXQoc3RyKSB7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ291dHB1dCcpLmlubmVySFRNTCArPSBgPGJyPiR7c3RyfWA7XG59XG53aW5kb3cuZ2V0U3RhdGUgPSAoKSA9PiBjb25zb2xlLmxvZygnYXBwLnN0YXRlJywgYXBwLnN0YXRlKTtcbi8qXG5UT0RPOiBnZXQgdG91Y2gtYWRkIHdvcmtpbmdcbi0tIGNyZWF0ZSBub2RlIHVzaW5nIHVzZXIncyBjb2xvclxuLS0gc2F2ZSBub2RlIGluZm8gdG8gbm9kZXMgYXJyYXlcblRPRE86IHNoYXJlIHN0YXRlIG92ZXIgd2Vic29ja2V0c1xuVE9ETzogdXBkYXRlIHN0YXRlIG9iamVjdCB3aGVuIHNvY2tldCBpbmZvIGNvbWVzIGluXG4gKi9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9tYWluLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoZSBUcnV0aCFcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBub2RlczogW10sXG4gICAgY29ubmVjdGlvbnM6IFtdLFxuICAgIHVzZXJzOiB7fSxcbiAgICBjdXJyZW50VXNlcjoge1xuICAgICAgICB1c2VySUQ6ICcnLFxuICAgICAgICBjb2xvcjogJydcbiAgICB9XG59O1xuXG4vKlxuZS5nLiBcbntcbiAgICBub2RlczogW3tcbiAgICAgICAgdXNlcklEOiAnZ3VpZCcsXG4gICAgICAgIGNvb3JkczogW3sgeDowLCB5OjAgfV0sXG4gICAgICAgIG5vZGVJRDogJ2d1aWQnXG4gICAgfV0sXG4gICAgY29ubmVjdGlvbnM6IFt7XG4gICAgICAgIGUxOiB7IHg6MCwgeTowIH0sXG4gICAgICAgIGUyOiB7IHg6MCwgeTowIH0sXG4gICAgfV0sXG4gICAgdXNlcnM6IHtcbiAgICAgICAgZ3VpZDoge1xuICAgICAgICAgICAgY29sb3I6ICcnXG4gICAgICAgIH1cbiAgICB9XG59XG4gKi9cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9zdGF0ZS5qcyIsIlwidXNlIHN0cmljdFwiO1xuLyogICovXG5pbXBvcnQgc3Bhd25Ob2RlIGZyb20gJy4vc3Bhd24tbm9kZS5qcyc7XG5pbXBvcnQgTmVhcmVzdE5vZGVzIGZyb20gJy4vZmluZC1uZWFyZXN0LW5vZGVzLmpzJztcblxubGV0IGNhbnZhcztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FudmFzU2V0dXAoYXBwKSB7XG4gICAgY29uc3QgbmVhcmVzdE5vZGVzID0gbmV3IE5lYXJlc3ROb2RlcyhhcHApO1xuICAgIGNhbnZhcyA9IG5ldyBmYWJyaWMuQ2FudmFzKCdzdGFnZScpO1xuXG4gICAgZmFicmljLkdyb3VwLnByb3RvdHlwZS5oYXNDb250cm9scyA9IGZhbHNlO1xuICAgIGNhbnZhcy5zZWxlY3Rpb24gPSBmYWxzZTtcbiAgICBcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgcmVzaXplQ2FudmFzLCBmYWxzZSk7XG4gICAgcmVzaXplQ2FudmFzKCk7XG4gICAgYXBwLnJlc2l6ZUNhbnZhcyA9IHJlc2l6ZUNhbnZhcztcbiAgICBhcHAuY2FudmFzID0gY2FudmFzO1xuXG4gICAgY2FudmFzLm9uKHtcbiAgICAgICAgJ21vdXNlOmRvd24nOiBldmVudCA9PiB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHNwYXduTm9kZShhcHAsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBuZWFyZXN0IDIgbm9kZXNcbiAgICAgICAgICAgICAgICAvLyBsZXQgbmVhcmVzdE5vZGVzID0gZmluZE5lYXJlc3ROb2RlcyhhcHAsIGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgLy8gbGV0IG5lYXJlc3ROb2RlcyA9IG5lYXJlc3ROb2Rlcy5maW5kQ2xvc2VzdFRvKGNvb3Jkcyk7XG4gICAgICAgICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIC8vLyBuZWVkIHRvIGNhbGMgY2xvc2VzdCBcbiAgICAgICAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgICAgICAgICAgICAgbGV0IG5uID0gbmVhcmVzdE5vZGVzLmZpbmRDbG9zZXN0VG8obm9kZSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgICdjbG9zZXN0Jywgbm4uY2xvc2VzdCxcbiAgICAgICAgICAgICAgICAgICAgJ25leHRDbG9zZXN0Jywgbm4ubmV4dENsb3Nlc3RcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIGRyYXcgbGluZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFwcDtcbn1cblxuZnVuY3Rpb24gcmVzaXplQ2FudmFzKCkge1xuICAgIGNhbnZhcy5zZXRIZWlnaHQod2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBjYW52YXMuc2V0V2lkdGgod2luZG93LmlubmVyV2lkdGgpO1xuICAgIGNhbnZhcy5yZW5kZXJBbGwoKTtcbn1cbi8vIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhbnZhc1NldHVwKGFwcCkge1xuLy8gICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhZ2UnKTtcbi8vICAgICBhcHAucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoY2FudmFzKTtcblxuLy8gICAgIHJldHVybiBhcHA7XG4vLyB9XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0cy9jbGllbnQvY2FudmFzLXNldHVwLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IGd1aWQgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuY29uc3Qgbm9kZVJhZGl1cyA9IDUwO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzcGF3bk5vZGUoYXBwLCBldmVudCkge1xuICAgIGxldCB7IHBhZ2VYLCBwYWdlWSB9ID0gZXZlbnQuZS50b3VjaGVzID8gZXZlbnQuZS50b3VjaGVzWzBdIDogZXZlbnQuZTtcbiAgICBpZiAoIWV2ZW50LnRhcmdldCkge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gLTIwO1xuICAgICAgICBsZXQgbm9kZUlEID0gZ3VpZCgpO1xuICAgICAgICBsZXQgY2VudGVyZWQgPSB7XG4gICAgICAgICAgICB4OiAocGFnZVggLSBub2RlUmFkaXVzKSxcbiAgICAgICAgICAgIHk6IChwYWdlWSAtIG5vZGVSYWRpdXMpLFxuICAgICAgICB9O1xuICAgICAgICBhZGRDaXJjbGUoe1xuICAgICAgICAgICAgeDogY2VudGVyZWQueCxcbiAgICAgICAgICAgIHk6IGNlbnRlcmVkLnksXG4gICAgICAgICAgICBjb2xvcjogYXBwLnN0YXRlLmN1cnJlbnRVc2VyLmNvbG9yLFxuICAgICAgICAgICAgY2FudmFzOiBhcHAuY2FudmFzLFxuICAgICAgICAgICAgbm9kZUlEXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgY3VycmVudFVzZXIgPSBhcHAuc3RhdGUuY3VycmVudFVzZXI7XG4gICAgICAgIGFwcC5zdGF0ZS5ub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvbG9yOiBjdXJyZW50VXNlci5jb2xvcixcbiAgICAgICAgICAgIGNvb3JkczogY2VudGVyZWQsXG4gICAgICAgICAgICB1c2VySUQ6IGN1cnJlbnRVc2VyLnVzZXJJRCxcbiAgICAgICAgICAgIG5vZGVJRFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgY2VudGVyZWQsIG5vZGVJRCB9O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkQ2lyY2xlKHt4LCB5LCBjb2xvciwgY2FudmFzLCBub2RlSUR9KSB7XG4gICAgLy8gY29uc29sZS5sb2coXCJ4LCB5LCBjb2xvciwgY2FudmFzXCIsIHgsIHksIGNvbG9yLCBjYW52YXMpO1xuICAgIGxldCBjaXJjbGUgPSBuZXcgZmFicmljLkNpcmNsZSh7XG4gICAgICAgIGxlZnQ6IHgsXG4gICAgICAgIHRvcDogeSxcbiAgICAgICAgcmFkaXVzOiBub2RlUmFkaXVzLFxuICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgaGFzQ29udHJvbHM6IGZhbHNlLFxuICAgICAgICBpZDogbm9kZUlEXG4gICAgfSk7XG4gICAgY2FudmFzLmFkZChjaXJjbGUpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3NjcmlwdHMvY2xpZW50L3NwYXduLW5vZGUuanMiLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbHMgTWF0aCAqL1xuXG5jb25zdCBlbXB0eUNvb3JkcyA9ICgpID0+IHsgcmV0dXJuIHsgeDpudWxsLCB5Om51bGwgfTsgfTtcbmxldCBjbG9zZXN0ID0gZW1wdHlDb29yZHMoKTtcbmxldCBuZXh0Q2xvc2VzdCA9IGVtcHR5Q29vcmRzKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5lYXJlc3ROb2RlcyB7XG4gICAgY29uc3RydWN0b3IoYXBwKSB7XG4gICAgICAgIC8vIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLm5vZGVzID0gYXBwLnN0YXRlLm5vZGVzO1xuICAgIH1cblxuICAgIC8vIG9ubHkgdXNpbmcgZ2V0dGVyL3NldHRlciBwYXR0ZXJuIGluIGNhc2UgSSBwYXNzIG9iamVjdCB0byBzZXQgY29vcmRzIGFuZCBpdCBoYXMgbW9yZSB0aGFuIHgveVxuICAgIGdldCBjbG9zZXN0KCkge1xuICAgICAgICByZXR1cm4gY2xvc2VzdDtcbiAgICB9XG4gICAgc2V0IGNsb3Nlc3Qoe3gsIHl9KSB7XG4gICAgICAgIGNsb3Nlc3QueCA9IHg7XG4gICAgICAgIGNsb3Nlc3QueSA9IHk7XG4gICAgfVxuICAgIGdldCBuZXh0Q2xvc2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIG5leHRDbG9zZXN0O1xuICAgIH1cbiAgICBzZXQgbmV4dENsb3Nlc3Qoe3gsIHl9KSB7XG4gICAgICAgIG5leHRDbG9zZXN0LnggPSB4O1xuICAgICAgICBuZXh0Q2xvc2VzdC55ID0geTtcbiAgICB9XG5cbiAgICBmaW5kQ2xvc2VzdFRvKHtjZW50ZXJlZDpjb29yZHMsIG5vZGVJRH0pIHtcbiAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHRtcE5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGVJRCA9PT0gdG1wTm9kZS5ub2RlSUQpIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKGNvb3Jkc0FyZU51bGwodGhpcy5jbG9zZXN0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VzdCA9IE9iamVjdC5hc3NpZ24oeyBub2RlSUQ6IHRtcE5vZGUubm9kZUlEIH0sIHRtcE5vZGUuY29vcmRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UoY29vcmRzLCB0aGlzLmNsb3Nlc3QpID4gZGlzdGFuY2UoY29vcmRzLCB0bXBOb2RlLmNvb3JkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2xvc2VzdCA9IHRoaXMuY2xvc2VzdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZXN0ID0gT2JqZWN0LmFzc2lnbih7IG5vZGVJRDogdG1wTm9kZS5ub2RlSUQgfSwgdG1wTm9kZS5jb29yZHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb29yZHNBcmVOdWxsKHRoaXMubmV4dENsb3Nlc3QpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZShjb29yZHMsIHRoaXMubmV4dENsb3Nlc3QpID4gZGlzdGFuY2UoY29vcmRzLCB0bXBOb2RlLmNvb3JkcykpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMubmV4dENsb3Nlc3QgPSBPYmplY3QuYXNzaWduKHsgbm9kZUlEOiB0bXBOb2RlLm5vZGVJRCB9LCB0bXBOb2RlLmNvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xvc2VzdDogdGhpcy5jbG9zZXN0LFxuICAgICAgICAgICAgbmV4dENsb3Nlc3Q6IHRoaXMubmV4dENsb3Nlc3QsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5mdW5jdGlvbiBjb29yZHNBcmVOdWxsKG9iaikge1xuICAgIHJldHVybiBpc051bGwob2JqLngpICYmIGlzTnVsbChvYmoueSk7XG59XG5mdW5jdGlvbiBkaXN0YW5jZSh7eDp4MSwgeTp5MX0sIHt4OngyLCB5OnkyfSkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGgucG93KCh4MSAtIHgyKSwgMikgKyBNYXRoLnBvdygoeTEgLSB5MiksIDIpXG4gICAgKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9maW5kLW5lYXJlc3Qtbm9kZXMuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IHsgZ3VpZCwgcmFuZG9tSGV4IH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkZFVzZXIoYXBwKSB7XG4gICAgbGV0IHVzZXJJRCA9IGd1aWQoKTtcbiAgICBsZXQgY29sb3IgPSByYW5kb21IZXgoKTtcbiAgICBhcHAuc3RhdGUudXNlcnNbdXNlcklEXSA9IHsgY29sb3IgfTtcblxuICAgIGFwcC5zdGF0ZS5jdXJyZW50VXNlciA9IHtcbiAgICAgICAgdXNlcklELCBjb2xvclxuICAgIH07XG5cbiAgICByZXR1cm4gYXBwO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9zY3JpcHRzL2NsaWVudC9hZGQtdXNlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBmdW5jdGlvbiBzNCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gczQoKSArIHM0KCkgKyAnLScgKyBzNCgpICsgJy0nICsgczQoKSArICctJyArIHM0KCkgKyAnLScgKyBzNCgpICsgczQoKSArIHM0KCk7XG4gICAgcmV0dXJuIGAke3M0KCl9JHtzNCgpfS0ke3M0KCl9LSR7czQoKX0tJHtzNCgpfS0ke3M0KCl9JHtzNCgpfSR7czQoKX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tSGV4KCkge1xuICAgIHJldHVybiAnIycgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMTY3NzcyMTUpLnRvU3RyaW5nKDE2KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlKGNvb3JkczEsIGNvb3JkczIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KChjb29yZHMxLnggLSBjb29yZHMyLngpLCAyKSArIE1hdGgucG93KChjb29yZHMxLnkgLSBjb29yZHMyLnkpLCAyKSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvc2NyaXB0cy9jbGllbnQvdXRpbHMuanMiXSwic291cmNlUm9vdCI6IiJ9